{"version":3,"file":"mutations.min.js","sources":["../../../src/local/courseeditor/mutations.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport ajax from 'core/ajax';\n\n/**\n * Default mutation manager\n *\n * @module     core_courseformat/local/courseeditor/mutations\n * @class     core_courseformat/local/courseeditor/mutations\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nexport default class {\n\n    // All course editor mutations for Moodle 4.0 will be located in this file.\n\n    /**\n     * Private method to call core_courseformat_update_course webservice.\n     *\n     * @method _callEditWebservice\n     * @param {string} action\n     * @param {number} courseId\n     * @param {array} ids\n     * @param {number} targetSectionId optional target section id (for moving actions)\n     * @param {number} targetCmId optional target cm id (for moving actions)\n     */\n    async _callEditWebservice(action, courseId, ids, targetSectionId, targetCmId) {\n        const args = {\n            action,\n            courseid: courseId,\n            ids,\n        };\n        if (targetSectionId) {\n            args.targetsectionid = targetSectionId;\n        }\n        if (targetCmId) {\n            args.targetcmid = targetCmId;\n        }\n        let ajaxresult = await ajax.call([{\n            methodname: 'core_courseformat_update_course',\n            args,\n        }])[0];\n        return JSON.parse(ajaxresult);\n    }\n\n\n    /**\n     * Mutation module initialize.\n     *\n     * The reactive instance will execute this method when addMutations or setMutation is invoked.\n     *\n     * @param {StateManager} stateManager the state manager\n     */\n    init(stateManager) {\n        // Add a method to prepare the fields when some update is comming from the server.\n        stateManager.addUpdateTypes({\n            prepareFields: this._prepareFields,\n        });\n    }\n\n    /**\n     * Add default values to state elements.\n     *\n     * This method is called every time a webservice returns a update state message.\n     *\n     * @param {Object} stateManager the state manager\n     * @param {String} updateName the state element to update\n     * @param {Object} fields the new data\n     * @returns {Object} final fields data\n     */\n    _prepareFields(stateManager, updateName, fields) {\n        // Any update should unlock the element.\n        fields.locked = false;\n        return fields;\n    }\n\n    /**\n     * Move course modules to specific course location.\n     *\n     * Note that one of targetSectionId or targetCmId should be provided in order to identify the\n     * new location:\n     *  - targetCmId: the activities will be located avobe the target cm. The targetSectionId\n     *                value will be ignored in this case.\n     *  - targetSectionId: the activities will be appended to the section. In this case\n     *                     targetSectionId should not be present.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmids the list of cm ids to move\n     * @param {number} targetSectionId the target section id\n     * @param {number} targetCmId the target course module id\n     */\n    async cmMove(stateManager, cmids, targetSectionId, targetCmId) {\n        if (!targetSectionId && !targetCmId) {\n            throw new Error(`Mutation cmMove requires targetSectionId or targetCmId`);\n        }\n        const course = stateManager.get('course');\n        this.cmLock(stateManager, cmids, true);\n        const updates = await this._callEditWebservice('cm_move', course.id, cmids, targetSectionId, targetCmId);\n        stateManager.processUpdates(updates);\n        this.cmLock(stateManager, cmids, false);\n    }\n\n    /**\n     * Move course modules to specific course location.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids to move\n     * @param {number} targetSectionId the target section id\n     */\n    async sectionMove(stateManager, sectionIds, targetSectionId) {\n        if (!targetSectionId) {\n            throw new Error(`Mutation sectionMove requires targetSectionId`);\n        }\n        const course = stateManager.get('course');\n        this.sectionLock(stateManager, sectionIds, true);\n        const updates = await this._callEditWebservice('section_move', course.id, sectionIds, targetSectionId);\n        stateManager.processUpdates(updates);\n        this.sectionLock(stateManager, sectionIds, false);\n    }\n\n    /**\n     * Add a new section to a specific course location.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {number} targetSectionId optional the target section id\n     */\n    async addSection(stateManager, targetSectionId) {\n        if (!targetSectionId) {\n            targetSectionId = 0;\n        }\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('section_add', course.id, [], targetSectionId);\n        stateManager.processUpdates(updates);\n    }\n\n    /**\n     * Delete sections.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of course modules ids\n     */\n    async sectionDelete(stateManager, sectionIds) {\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('section_delete', course.id, sectionIds);\n        stateManager.processUpdates(updates);\n    }\n\n    /**\n     * Mark or unmark course modules as dragging.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of course modules ids\n     * @param {bool} dragValue the new dragging value\n     */\n    cmDrag(stateManager, cmIds, dragValue) {\n        this.setPageItem(stateManager);\n        this._setElementsValue(stateManager, 'cm', cmIds, 'dragging', dragValue);\n    }\n\n    /**\n     * Mark or unmark course sections as dragging.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids\n     * @param {bool} dragValue the new dragging value\n     */\n    sectionDrag(stateManager, sectionIds, dragValue) {\n        this.setPageItem(stateManager);\n        this._setElementsValue(stateManager, 'section', sectionIds, 'dragging', dragValue);\n    }\n\n    /**\n     * Mark or unmark course modules as complete.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of course modules ids\n     * @param {bool} complete the new completion value\n     */\n    cmCompletion(stateManager, cmIds, complete) {\n        const newValue = (complete) ? 1 : 0;\n        this._setElementsValue(stateManager, 'cm', cmIds, 'completionstate', newValue);\n    }\n\n    /**\n     * Lock or unlock course modules.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} cmIds the list of course modules ids\n     * @param {bool} lockValue the new locked value\n     */\n    cmLock(stateManager, cmIds, lockValue) {\n        this._setElementsValue(stateManager, 'cm', cmIds, 'locked', lockValue);\n    }\n\n    /**\n     * Lock or unlock course sections.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the list of section ids\n     * @param {bool} lockValue the new locked value\n     */\n    sectionLock(stateManager, sectionIds, lockValue) {\n        this._setElementsValue(stateManager, 'section', sectionIds, 'locked', lockValue);\n    }\n\n    _setElementsValue(stateManager, name, ids, fieldName, newValue) {\n        stateManager.setReadOnly(false);\n        ids.forEach((id) => {\n            const element = stateManager.get(name, id);\n            if (element) {\n                element[fieldName] = newValue;\n            }\n        });\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Set the page current item.\n     *\n     * Only one element of the course state can be the page item at a time.\n     *\n     * There are several actions that can alter the page current item. For example, when the user is in an activity\n     * page, the page item is always the activity one. However, in a course page, when the user scrolls to an element,\n     * this element get the page item.\n     *\n     * If the page item is static means that it is not meant to change. This is important because\n     * static page items has some special logic. For example, if a cm is the static page item\n     * and it is inside a collapsed section, the course index will expand the section to make it visible.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {String|undefined} type the element type (section or cm). Undefined will remove the current page item.\n     * @param {Number|undefined} id the element id\n     * @param {boolean|undefined} isStatic if the page item is static\n     */\n    setPageItem(stateManager, type, id, isStatic) {\n        let newPageItem;\n        if (type !== undefined) {\n            newPageItem = stateManager.get(type, id);\n            if (!newPageItem) {\n                return;\n            }\n        }\n        stateManager.setReadOnly(false);\n        // Remove the current page item.\n        const course = stateManager.get('course');\n        course.pageItem = null;\n        // Save the new page item.\n        if (newPageItem) {\n            course.pageItem = {\n                id,\n                type,\n                sectionId: (type == 'section') ? newPageItem.id : newPageItem.sectionid,\n                isStatic,\n            };\n        }\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Unlock all course elements.\n     *\n     * @param {StateManager} stateManager the current state manager\n     */\n    unlockAll(stateManager) {\n        const state = stateManager.state;\n        stateManager.setReadOnly(false);\n        state.section.forEach((section) => {\n            section.locked = false;\n        });\n        state.cm.forEach((cm) => {\n            cm.locked = false;\n        });\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Update the course index collapsed attribute of some sections.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the affected section ids\n     * @param {boolean} collapsed the new collapsed value\n     */\n    async sectionIndexCollapsed(stateManager, sectionIds, collapsed) {\n        const collapsedIds = this._updateStateSectionPreference(stateManager, 'indexcollapsed', sectionIds, collapsed);\n        const course = stateManager.get('course');\n        await this._callEditWebservice('section_index_collapsed', course.id, collapsedIds);\n    }\n\n    /**\n     * Update the course content collapsed attribute of some sections.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {array} sectionIds the affected section ids\n     * @param {boolean} collapsed the new collapsed value\n     */\n    async sectionContentCollapsed(stateManager, sectionIds, collapsed) {\n        const collapsedIds = this._updateStateSectionPreference(stateManager, 'contentcollapsed', sectionIds, collapsed);\n        const course = stateManager.get('course');\n        await this._callEditWebservice('section_content_collapsed', course.id, collapsedIds);\n    }\n\n    /**\n     * Private batch update for a section preference attribute.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {string} preferenceName the preference name\n     * @param {array} sectionIds the affected section ids\n     * @param {boolean} preferenceValue the new preferenceValue value\n     * @return {array} the list of all sections with that preference set to true\n     */\n    _updateStateSectionPreference(stateManager, preferenceName, sectionIds, preferenceValue) {\n        stateManager.setReadOnly(false);\n        const affectedSections = new Set();\n        // Check if we need to update preferences.\n        sectionIds.forEach(sectionId => {\n            const section = stateManager.get('section', sectionId);\n            if (section === undefined) {\n                return;\n            }\n            const newValue = preferenceValue ?? section[preferenceName];\n            if (section[preferenceName] != newValue) {\n                section[preferenceName] = newValue;\n                affectedSections.add(section.id);\n            }\n        });\n        stateManager.setReadOnly(true);\n        if (affectedSections.size == 0) {\n            return [];\n        }\n        // Get all collapsed section ids.\n        const collapsedSectionIds = [];\n        const state = stateManager.state;\n        state.section.forEach(section => {\n            if (section[preferenceName]) {\n                collapsedSectionIds.push(section.id);\n            }\n        });\n        return collapsedSectionIds;\n    }\n\n    /**\n     * Get updated state data related to some cm ids.\n     *\n     * @method cmState\n     * @param {StateManager} stateManager the current state\n     * @param {array} cmids the list of cm ids to update\n     */\n    async cmState(stateManager, cmids) {\n        this.cmLock(stateManager, cmids, true);\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('cm_state', course.id, cmids);\n        stateManager.processUpdates(updates);\n        this.cmLock(stateManager, cmids, false);\n    }\n\n    /**\n     * Get updated state data related to some section ids.\n     *\n     * @method sectionState\n     * @param {StateManager} stateManager the current state\n     * @param {array} sectionIds the list of section ids to update\n     */\n    async sectionState(stateManager, sectionIds) {\n        this.sectionLock(stateManager, sectionIds, true);\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('section_state', course.id, sectionIds);\n        stateManager.processUpdates(updates);\n        this.sectionLock(stateManager, sectionIds, false);\n    }\n\n    /**\n     * Get the full updated state data of the course.\n     *\n     * @param {StateManager} stateManager the current state\n     */\n    async courseState(stateManager) {\n        const course = stateManager.get('course');\n        const updates = await this._callEditWebservice('course_state', course.id);\n        stateManager.processUpdates(updates);\n    }\n\n}\n"],"names":["action","courseId","ids","targetSectionId","targetCmId","args","courseid","targetsectionid","targetcmid","ajax","call","methodname","ajaxresult","JSON","parse","stateManager","addUpdateTypes","prepareFields","this","_prepareFields","updateName","fields","locked","cmids","Error","course","get","cmLock","_callEditWebservice","id","updates","processUpdates","sectionIds","sectionLock","cmIds","dragValue","setPageItem","_setElementsValue","complete","newValue","lockValue","name","fieldName","setReadOnly","forEach","element","type","isStatic","newPageItem","undefined","pageItem","sectionId","sectionid","state","section","cm","collapsed","collapsedIds","_updateStateSectionPreference","preferenceName","preferenceValue","affectedSections","Set","add","size","collapsedSectionIds","push"],"mappings":"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"}