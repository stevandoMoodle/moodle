{"version":3,"file":"checker.min.js","sources":["../src/checker.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/*\n * @package    tiny_accessibilitychecker\n * @copyright  2022, Stevani Andolo  <stevani@hotmail.com.au>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport {get_string as getString} from 'core/str';\nimport {saveCancelPromise} from 'core/notification';\nimport {component} from './common';\nimport * as Modal from 'core/modal_factory';\nimport * as ModalEvents from 'core/modal_events';\nimport {ColorBase} from './colorbase';\n\nexport default class {\n\n    constructor(editor) {\n        this.editor = editor;\n        this.colorBase = new ColorBase();\n        this.selectedNode = null;\n        this.modal = null;\n    }\n\n    async displayDialogue() {\n        await this.setSelectedNode();\n        Modal.create({\n            type: Modal.types.DEFAULT,\n            large: true,\n            title: getString('pluginname', component),\n            body: this.getDialogueContent()\n        }).then(modal => {\n            this.modal = modal;\n            modal.getRoot().on(ModalEvents.hidden, () => {\n                if (!this.selectedNode || (this.selectedNode && !['TD', 'TABLE'].includes(this.selectedNode.nodeName))) {\n                    if (this.selectedNode) {\n                        this.selectAndScroll(this.selectedNode);\n                    }\n                    this.editor.dom.select('body')[0].focus();\n                }\n                modal.destroy();\n                this.selectedNode = null;\n            });\n            modal.show();\n            return modal;\n        }).catch();\n    }\n\n    /**\n     * Set selected node if any has been selected.\n     *\n     * @method setSelectedNode\n     * @return {boolean} The content to place in the dialogue.\n     */\n    async setSelectedNode() {\n        const selectedNode = this.editor.selection.getNode();\n\n        // Set the selected node if the current selected node is not 'body'.\n        if (selectedNode.nodeName !== 'BODY') {\n            this.selectedNode = selectedNode;\n        }\n\n        // Set the selected node to null if:\n        // 1. Selected node name is 'p' and is empty,\n        // 2. Or selected node name is 'br',\n        // 3. Or selected node name is 'br' and has 'data-mce-bogus' attribute.\n        if (this.selectedNode?.nodeName === 'P' && this.selectedNode?.textContent === '' ||\n            this.selectedNode?.nodeName === 'BR' ||\n            this.selectedNode?.nodeName === 'BR' && this.selectedNode?.hasAttribute('data-mce-bogus')) {\n            this.selectedNode = null;\n        }\n\n        // Set selected node to null if user chose 'Yes' from the confirmation.\n        if (this.selectedNode) {\n            const checkAll = await this.checkConfirmation();\n            this.selectedNode = checkAll ? null : this.selectedNode;\n        }\n    }\n\n    /**\n     * Confirm whether the user wants to do the accessibility check on selected element or everything.\n     *\n     * @returns {Promise<boolean>} Whether the user confirmed the check.\n     */\n    async checkConfirmation() {\n        try {\n            await saveCancelPromise(\n                getString(\"check_title\", component),\n                getString(\"check_desc\", component),\n                getString(\"confirm_yes\", component)\n            );\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Return the dialogue content.\n     *\n     * @method getDialogueContent\n     * @return {Node} The content to place in the dialogue.\n     */\n     async getDialogueContent() {\n        let currentdesc = '';\n        let warnings = [];\n        const promises = this.getWarnings().map(async(top) => {\n            let object = [];\n            top.map(async(warning) => {\n                if (warning.key?.includes(':stringlang')) {\n                    warning.key = warning.key.split(':stringlang')[0];\n                }\n                currentdesc = (currentdesc === warning.key) ? currentdesc : warning.key;\n\n                if (warning.text?.includes(':stringlang')) {\n                    warning.text = await getString(warning.text.split(':stringlang')[0], component);\n                }\n                object.push(warning);\n            });\n            warnings.push({\n                description: await getString(currentdesc, component),\n                dataobject: object\n            });\n        });\n        await Promise.all(promises);\n        const content = await Templates.render('tiny_accessibilitychecker/warning_content', {data: warnings});\n        const parsedHtml = this.parseHtml(content);\n        return this.setSelectionListener(parsedHtml);\n    }\n\n    /**\n     * Parsed string of htmls into html elements.\n     *\n     * @method parseHtml\n     * @param {html} html\n     * @return {node} parsed html\n     */\n    parseHtml(html) {\n        var parser = new DOMParser();\n        var doc = parser.parseFromString(html, 'text/html');\n        return doc.body.firstElementChild;\n    }\n\n    /**\n     * Add listerner to every anchor to perform a selection.\n     *\n     * @method setSelectionListener\n     * @param {content} content\n     * @return {content}\n     */\n    setSelectionListener(content) {\n        content.querySelectorAll('a').forEach(anchor => {\n            anchor.addEventListener('click', (e) => {\n                e.preventDefault();\n                const node = e.currentTarget.getAttribute('sourceNode');\n                let nodeId = e.currentTarget.getAttribute('nodeId');\n                nodeId = (nodeId === 'null') ? 0 : nodeId;\n\n                if (node) {\n                    if (node.includes(',') || node === 'body') {\n                        this.selectAndScroll(this.editor.dom.select('body')[0]);\n                    } else {\n                        this.selectAndScroll(this.editor.dom.select(node)[nodeId]);\n                    }\n                }\n                this.closeModal();\n            });\n        });\n        return content;\n    }\n\n    /**\n     * Set the selection and scroll to the selected element.\n     *\n     * @method selectAndScroll\n     * @param {Node} node\n     */\n    selectAndScroll(node) {\n        this.selectedNode = node;\n        this.editor.selection.select(node).scrollIntoView({\n            behavior: 'smooth', block: 'nearest'\n        });\n    }\n\n    /**\n     * Close current modal.\n     *\n     * @method closeModal\n     */\n    closeModal() {\n        this.modal.destroy();\n    }\n\n    /**\n     * Find all problems with the content editable region.\n     *\n     * @method getWarnings\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    getWarnings() {\n        let warnings = [];\n        let selectedNodeName = this.selectedNode ? this.selectedNode.nodeName.toLowerCase() : null;\n        selectedNodeName = selectedNodeName === 'td' ? 'table' : selectedNodeName;\n\n        // Check Images with no alt text or dodgy alt text.\n        if (selectedNodeName === null || selectedNodeName === 'img') {\n            const warning = this.createWarning('imagesmissingalt', this.checkImage(), true);\n            if (warning.length > 0) {\n                warnings.push(warning);\n            }\n        }\n\n        if (selectedNodeName === null || (selectedNodeName !== 'img' && selectedNodeName !== 'table')) {\n            const warning = this.createWarning('needsmorecontrast', this.checkOtherElements(selectedNodeName), false);\n            if (warning.length > 0) {\n                warnings.push(warning);\n            }\n        }\n\n        // Check for no headings.\n        if (this.editor.getContent({format: 'text'}).length > 1000 && this.editor.dom.select('h3,h4,h5').length < 1) {\n            const warning = this.createWarning('needsmoreheadings', [this.editor], false);\n            if (warning.length > 0) {\n                warnings.push(warning);\n            }\n        }\n\n        if (selectedNodeName === null || selectedNodeName === 'table') {\n            // Check for tables with no captions.\n            const capwarning = this.createWarning('tablesmissingcaption', this.checkTableCaption(), false);\n            if (capwarning.length > 0) {\n                warnings.push(capwarning);\n            }\n\n            // Check for tables with merged cells.\n            const mergedwarning = this.createWarning('tableswithmergedcells', this.checkTableMergedCells(), false);\n            if (mergedwarning.length > 0) {\n                warnings.push(mergedwarning);\n            }\n\n            // Check for tables with no row/col headers.\n            const headerwarning = this.createWarning('tablesmissingheaders', this.checkTableHeaders(), false);\n            if (headerwarning.length > 0) {\n                warnings.push(headerwarning);\n            }\n        }\n\n        if (warnings.length < 1) {\n            warnings.push([{\n                key: this.selectedNode ? 'nowarningonselected:stringlang' : 'nowarnings:stringlang',\n                nowarning: true\n            }]);\n        }\n        return warnings;\n    }\n\n    /**\n     * Generate the HTML that lists the found warnings.\n     *\n     * @method createWarning\n     * @param {String} description Description of this failure.\n     * @param {array} nodes An array of failing nodes.\n     * @param {boolean} imagewarnings true if the warnings are related to images, false if text.\n     * @return {array} array of objects\n     */\n    createWarning(description, nodes, imagewarnings) {\n        let warnings = [];\n        let text, src;\n        for (let i = 0; i < nodes.length; i++) {\n            if (imagewarnings) {\n                src = nodes[i].getAttribute('src');\n            } else {\n                if ('innerText' in nodes[i]) {\n                    text = nodes[i].innerText.trim();\n                } else if ('textContent' in nodes[i]) {\n                    text = nodes[i].textContent.trim();\n                }\n\n                if (text === '') {\n                    text = 'emptytext:stringlang';\n                }\n\n                if (nodes[i] === this.editor) {\n                    text = 'entiredocument:stringlang';\n                    const childnodes = nodes[i].dom.select('body')[0].childNodes;\n                    if (childnodes.length > 1) {\n                        nodes[i] = 'body';\n                    } else {\n                        nodes[i] = childnodes.nodeName.toLowerCase();\n                    }\n                }\n                text = text ?? nodes[i].nodeName;\n            }\n            warnings.push({\n                key: description,\n                sourceNode: (typeof nodes[i] === 'string') ? nodes[i] : nodes[i].nodeName.toLowerCase(),\n                nodeId: nodes[i].getAttribute('nodeId'),\n                text: text,\n                img: src\n            });\n        }\n        return warnings;\n    }\n\n    /**\n     * Check accessiblity issue only for img type.\n     *\n     * @method checkImage\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkImage() {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select('img').forEach(img => {\n            img.setAttribute('nodeId', index);\n            let alt = img.getAttribute('alt');\n            if (typeof alt === 'undefined' || alt === '' || alt === null) {\n                if (img.getAttribute('role') !== 'presentation') {\n                    problemNodes.push(img);\n                }\n            }\n            index += 1;\n        });\n        return problemNodes;\n    }\n\n    /**\n     * Check accessiblity issue only for table with no caption.\n     *\n     * @method checkTableCaption\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkTableCaption() {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select('table').forEach(function(table) {\n            table.setAttribute('nodeId', index);\n            let caption = table.querySelector('caption');\n            if (caption === null || caption.textContent.trim() === '') {\n                problemNodes.push(table);\n            }\n            index += 1;\n        });\n        return problemNodes;\n    }\n\n    /**\n     * Check accessiblity issue for not img and table only.\n     *\n     * @method checkOtherElements\n     * @param {node} node\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkOtherElements(node) {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select(node ?? 'body').forEach(node => {\n            node.setAttribute('nodeId', index);\n            let foreground,\n                background,\n                ratio,\n                lum1,\n                lum2;\n\n            // Check for non-empty text.\n            if (node.textContent.trim() !== '') {\n                foreground = this.colorBase.fromArray(\n                    this.getComputedBackgroundColor(\n                        node,\n                        window.getComputedStyle(node, null).getPropertyValue('color')\n                    ),\n                    this.colorBase.TYPES.RGBA\n                );\n                background = this.colorBase.fromArray(\n                    this.getComputedBackgroundColor(\n                        node\n                    ),\n                    this.colorBase.TYPES.RGBA\n                );\n\n                lum1 = this.getLuminanceFromCssColor(foreground);\n                lum2 = this.getLuminanceFromCssColor(background);\n\n                // Algorithm from \"http://www.w3.org/TR/WCAG20-GENERAL/G18.html\".\n                if (lum1 > lum2) {\n                    ratio = (lum1 + 0.05) / (lum2 + 0.05);\n                } else {\n                    ratio = (lum2 + 0.05) / (lum1 + 0.05);\n                }\n\n                if (ratio <= 4.5) {\n                    window.console.log(`\n                        Contrast ratio is too low: ${ratio}\n                        Colour 1: ${foreground}\n                        Colour 2: ${background}\n                        Luminance 1: ${lum1}\n                        Luminance 2: ${lum2}\n                    `);\n\n                    // We only want the highest node with dodgy contrast reported.\n                    let i = 0;\n                    let found = false;\n                    for (i = 0; i < problemNodes.length; i++) {\n                        if (node.parentElement.indexOf(problemNodes[i]) !== -1) {\n                            found = true;\n                            break;\n                        } else if (problemNodes[i].parentElement.indexOf(node) !== -1) {\n                            problemNodes[i] = node;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        problemNodes.push(node);\n                    }\n                }\n            }\n            index += 1;\n        });\n        return problemNodes;\n    }\n\n    /**\n     * Check accessiblity issue only for table with merged celss.\n     *\n     * @method checkTableMergedCells\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkTableMergedCells() {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select('table').forEach(table => {\n            table.setAttribute('nodeId', index);\n            let rowcolspan = table.querySelectorAll('[colspan], [rowspan]');\n            if (rowcolspan.length > 0) {\n                problemNodes.push(table);\n            }\n            index += 1;\n        });\n        return problemNodes;\n    }\n\n    /**\n     * Check accessiblity issue only for table with no headers.\n     *\n     * @method checkTableHeaders\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkTableHeaders() {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select('table').forEach(function(table) {\n            table.setAttribute('nodeId', index);\n            if (table.querySelectorAll('tr, td')) {\n                table.querySelectorAll('tr').forEach(row => {\n                    let header = row.querySelector('th');\n                    if (!header || (header.textContent.trim() === '')) {\n                        problemNodes.push(table);\n                    }\n                });\n            } else {\n                let hasHeader = false;\n                table.querySelector('tr').querySelectorAll('th').some(header => {\n                    hasHeader = true;\n                    if (header.textContent.trim() === '') {\n                        problemNodes.push(table);\n                        return true;\n                    }\n                    return false;\n                });\n                if (!hasHeader) {\n                    problemNodes.push(table);\n                }\n            }\n            index += 1;\n        });\n        return problemNodes;\n    }\n\n    /**\n     * Convert a CSS color to a luminance value.\n     *\n     * @method getLuminanceFromCssColor\n     * @param {String} colortext The Hex value for the colour\n     * @return {Number} The luminance value.\n     * @private\n     */\n    getLuminanceFromCssColor(colortext) {\n        let color;\n\n        if (colortext === 'transparent') {\n            colortext = '#ffffff';\n        }\n        color = this.colorBase.toArray(this.colorBase.toRGB(colortext));\n\n        // Algorithm from \"http://www.w3.org/TR/WCAG20-GENERAL/G18.html\".\n        let part1 = function(a) {\n            a = parseInt(a, 10) / 255.0;\n            if (a <= 0.03928) {\n                a = a / 12.92;\n            } else {\n                a = Math.pow(((a + 0.055) / 1.055), 2.4);\n            }\n            return a;\n        };\n\n        let r1 = part1(color[0]),\n            g1 = part1(color[1]),\n            b1 = part1(color[2]);\n\n        return 0.2126 * r1 + 0.7152 * g1 + 0.0722 * b1;\n    }\n\n    /**\n     * Get the computed RGB converted to full alpha value, considering the node hierarchy.\n     *\n     * @method getComputedBackgroundColor\n     * @param {Node} node\n     * @param {String} color The initial colour. If not specified, fetches the backgroundColor from the node.\n     * @return {Array} Colour in Array form (RGBA)\n     * @private\n     */\n    getComputedBackgroundColor(node, color) {\n        color = color ? color : window.getComputedStyle(node, null).getPropertyValue('background-color');\n        if (color.toLowerCase() === 'transparent') {\n            color = 'rgba(1, 1, 1, 0)';\n        }\n\n        // Convert the colour to its constituent parts in RGBA format, then fetch the alpha.\n        let colorParts = this.colorBase.toArray(color);\n        let alpha = colorParts[3];\n\n        if (alpha === 1) {\n            // If the alpha of the background is already 1, then the parent background colour does not change anything.\n            return colorParts;\n        }\n\n        // Fetch the computed background colour of the parent and use it to calculate the RGB of this item.\n        let parentColor = this.getComputedBackgroundColor(node.parentNode);\n        return [\n            // RGB = (alpha * R|G|B) + (1 - alpha * solid parent colour).\n            (1 - alpha) * parentColor[0] + alpha * colorParts[0],\n            (1 - alpha) * parentColor[1] + alpha * colorParts[1],\n            (1 - alpha) * parentColor[2] + alpha * colorParts[2],\n            // We always return a colour with full alpha.\n            1\n        ];\n    }\n}\n"],"names":["constructor","editor","colorBase","ColorBase","selectedNode","modal","this","setSelectedNode","Modal","create","type","types","DEFAULT","large","title","component","body","getDialogueContent","then","getRoot","on","ModalEvents","hidden","includes","nodeName","selectAndScroll","dom","select","focus","destroy","show","catch","selection","getNode","textContent","_this$selectedNode5","hasAttribute","checkAll","checkConfirmation","currentdesc","warnings","promises","getWarnings","map","async","object","top","warning","key","_warning$key","split","text","_warning$text","push","description","dataobject","Promise","all","content","Templates","render","data","parsedHtml","parseHtml","setSelectionListener","html","DOMParser","parseFromString","firstElementChild","querySelectorAll","forEach","anchor","addEventListener","e","preventDefault","node","currentTarget","getAttribute","nodeId","closeModal","scrollIntoView","behavior","block","selectedNodeName","toLowerCase","createWarning","checkImage","length","checkOtherElements","getContent","format","capwarning","checkTableCaption","mergedwarning","checkTableMergedCells","headerwarning","checkTableHeaders","nowarning","nodes","imagewarnings","src","i","innerText","trim","childnodes","childNodes","sourceNode","img","problemNodes","index","setAttribute","alt","table","caption","querySelector","foreground","background","ratio","lum1","lum2","fromArray","getComputedBackgroundColor","window","getComputedStyle","getPropertyValue","TYPES","RGBA","getLuminanceFromCssColor","console","log","found","parentElement","indexOf","row","header","hasHeader","some","colortext","color","toArray","toRGB","part1","a","parseInt","Math","pow","colorParts","alpha","parentColor","parentNode"],"mappings":"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"}