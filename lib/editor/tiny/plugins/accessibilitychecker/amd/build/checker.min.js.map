{"version":3,"file":"checker.min.js","sources":["../src/checker.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/*\n * @package    tiny_accessibilitychecker\n * @copyright  2022, Stevani Andolo  <stevani@hotmail.com.au>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport {get_string as getString} from 'core/str';\nimport {saveCancelPromise} from 'core/notification';\nimport {component} from './common';\nimport * as Modal from 'core/modal_factory';\nimport * as ModalEvents from 'core/modal_events';\nimport {ColorBase} from './colorbase';\n\nexport const Checker = class {\n\n    constructor(editor) {\n        this.editor = editor;\n        this.colorBase = new ColorBase();\n        this.selectedNode = null;\n        this.modal = null;\n    }\n\n    displayDialogue = async() => {\n        await this.setSelectedNode();\n        Modal.create({\n            type: Modal.types.DEFAULT,\n            large: true,\n            title: getString('pluginname', component),\n            body: this.getDialogueContent()\n        }).then(modal => {\n            this.modal = modal;\n            modal.getRoot().on(ModalEvents.hidden, () => {\n                if (!this.selectedNode || (this.selectedNode && !['TD', 'TABLE'].includes(this.selectedNode.nodeName))) {\n                    if (this.selectedNode) {\n                        this.selectAndScroll(this.selectedNode);\n                    }\n                    this.editor.dom.select('body')[0].focus();\n                }\n                modal.destroy();\n                this.selectedNode = null;\n            });\n            modal.show();\n            return modal;\n        }).catch();\n    };\n\n    /**\n     * Set selected node if any has been selected.\n     *\n     * @method setSelectedNode\n     * @return {boolean} The content to place in the dialogue.\n     */\n    setSelectedNode = async() => {\n        const selectedNode = this.editor.selection.getNode();\n\n        // Set the selected node if the current selected node is not 'body'.\n        if (selectedNode.nodeName !== 'BODY') {\n            this.selectedNode = selectedNode;\n        }\n\n        // Set the selected node to null if:\n        // 1. Selected node name is 'p' and is empty,\n        // 2. Or selected node name is 'br',\n        // 3. Or selected node name is 'br' and has 'data-mce-bogus' attribute.\n        if (this.selectedNode?.nodeName === 'P' && this.selectedNode?.textContent === '' ||\n            this.selectedNode?.nodeName === 'BR' ||\n            this.selectedNode?.nodeName === 'BR' && this.selectedNode?.hasAttribute('data-mce-bogus')) {\n            this.selectedNode = null;\n        }\n\n        // Set selected node to null if user chose 'Yes' from the confirmation.\n        if (this.selectedNode) {\n            const checkAll = await this.checkConfirmation();\n            this.selectedNode = checkAll ? null : this.selectedNode;\n        }\n    };\n\n    /**\n     * Confirm whether the user wants to do the accessibility check on selected element or everything.\n     *\n     * @returns {Promise<boolean>} Whether the user confirmed the check.\n     */\n    checkConfirmation = async() => {\n        try {\n            await saveCancelPromise(\n                await getString(\"check_title\", component),\n                await getString(\"check_desc\", component),\n                await getString(\"confirm_yes\", component)\n            );\n            return true;\n        } catch {\n            return false;\n        }\n    };\n\n    /**\n     * Return the dialogue content.\n     *\n     * @method getDialogueContent\n     * @return {Node} The content to place in the dialogue.\n     */\n    getDialogueContent = async() => {\n        const content = await Templates.render('tiny_accessibilitychecker/warning_content', {\n            warning: await this.getWarnings()\n        });\n        const parsedHtml = this.parseHtml(content);\n        this.setSelection(parsedHtml);\n        return parsedHtml;\n    };\n\n    /**\n     * Parsed string of htmls into html elements.\n     *\n     * @method parseHtml\n     * @param {html} html\n     * @return {node} parsed html\n     */\n    parseHtml = (html) => {\n        var parser = new DOMParser();\n        var doc = parser.parseFromString(html, 'text/html');\n        return doc.body.firstElementChild;\n    };\n\n    /**\n     * Add listerner to every anchor to perform a selection.\n     *\n     * @method setSelection\n     * @param {content} content\n     */\n    setSelection = (content) => {\n        content.querySelectorAll('a').forEach(anchor => {\n            anchor.addEventListener('click', (e) => {\n                e.preventDefault();\n                const node = e.currentTarget.getAttribute('sourceNode');\n                let nodeId = e.currentTarget.getAttribute('nodeId');\n                nodeId = (nodeId === 'null') ? 0 : nodeId;\n\n                if (node) {\n                    if (node.includes(',') || node === 'body') {\n                        this.selectAndScroll(this.editor.dom.select('body')[0]);\n                    } else {\n                        this.selectAndScroll(this.editor.dom.select(node)[nodeId]);\n                    }\n                }\n                this.closeModal();\n            });\n        });\n    };\n\n    /**\n     * Set the selection and scroll to the selected element.\n     *\n     * @method selectAndScroll\n     * @param {Node} node\n     */\n    selectAndScroll = (node) => {\n        this.selectedNode = node;\n        this.editor.selection.select(node).scrollIntoView({\n            behavior: 'smooth', block: 'nearest'\n        });\n    };\n\n    /**\n     * Close current modal.\n     *\n     * @method closeModal\n     */\n    closeModal = () => {\n        this.modal.destroy();\n    };\n\n    /**\n     * Find all problems with the content editable region.\n     *\n     * @method getWarnings\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    getWarnings = async() => {\n        let list = '';\n        let selectedNodeName = this.selectedNode ? this.selectedNode.nodeName.toLowerCase() : null;\n        selectedNodeName = selectedNodeName === 'td' ? 'table' : selectedNodeName;\n\n        // Check Images with no alt text or dodgy alt text.\n        if (selectedNodeName === null || selectedNodeName === 'img') {\n            const imagesmissingalt = await getString('imagesmissingalt', component);\n            list += await this.addWarnings(imagesmissingalt, this.checkImage(), true);\n        }\n\n        if (selectedNodeName === null || (selectedNodeName !== 'img' && selectedNodeName !== 'table')) {\n            // Check for eny elements but img and table.\n            const needsmorecontrast = await getString('needsmorecontrast', component);\n            list += await this.addWarnings(needsmorecontrast, this.checkOtherElements(selectedNodeName), false);\n        }\n\n        // Check for no headings.\n        if (this.editor.getContent({format: 'text'}).length > 1000 && this.editor.dom.select('h3,h4,h5').length < 1) {\n            const needsmoreheadings = await getString('needsmoreheadings', component);\n            list += await this.addWarnings(needsmoreheadings, [this.editor], false);\n        }\n\n        if (selectedNodeName === null || selectedNodeName === 'table') {\n            // Check for tables with no captions.\n            const tablesmissingcaption = await getString('tablesmissingcaption', component);\n            list += await this.addWarnings(tablesmissingcaption, this.checkTableCaption(), false);\n\n            // Check for tables with merged cells.\n            const tableswithmergedcells = await getString('tableswithmergedcells', component);\n            list += await this.addWarnings(tableswithmergedcells, this.checkTableMergedCells(), false);\n\n            // Check for tables with no row/col headers.\n            const tablesmissingheaders = await getString('tablesmissingheaders', component);\n            list += await this.addWarnings(tablesmissingheaders, this.checkTableHeaders(), false);\n        }\n\n        if (list === '') {\n            list = await Templates.render('tiny_accessibilitychecker/success', {\n                message: await getString(this.selectedNode ? 'nowarningonselected' : 'nowarnings', component)\n            });\n        }\n        return list;\n    };\n\n    /**\n     * Check accessiblity issue only for img type.\n     *\n     * @method checkImage\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkImage = () => {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select('img').forEach(img => {\n            img.setAttribute('nodeId', index);\n            let alt = img.getAttribute('alt');\n            if (typeof alt === 'undefined' || alt === '' || alt === null) {\n                if (img.getAttribute('role') !== 'presentation') {\n                    problemNodes.push(img);\n                }\n            }\n            index += 1;\n        });\n        return problemNodes;\n    };\n\n    /**\n     * Check accessiblity issue only for table with no caption.\n     *\n     * @method checkTableCaption\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkTableCaption = () => {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select('table').forEach(function(table) {\n            table.setAttribute('nodeId', index);\n            let caption = table.querySelector('caption');\n            if (caption === null || caption.textContent.trim() === '') {\n                problemNodes.push(table);\n            }\n            index += 1;\n        });\n        return problemNodes;\n    };\n\n    /**\n     * Check accessiblity issue for not img and table only.\n     *\n     * @method checkOtherElements\n     * @param {node} node\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkOtherElements = (node) => {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select(node ?? 'body').forEach(node => {\n            node.setAttribute('nodeId', index);\n            let foreground,\n                background,\n                ratio,\n                lum1,\n                lum2;\n\n            // Check for non-empty text.\n            if (node.textContent.trim() !== '') {\n                foreground = this.colorBase.fromArray(\n                    this.getComputedBackgroundColor(\n                        node,\n                        window.getComputedStyle(node, null).getPropertyValue('color')\n                    ),\n                    this.colorBase.TYPES.RGBA\n                );\n                background = this.colorBase.fromArray(\n                    this.getComputedBackgroundColor(\n                        node\n                    ),\n                    this.colorBase.TYPES.RGBA\n                );\n\n                lum1 = this.getLuminanceFromCssColor(foreground);\n                lum2 = this.getLuminanceFromCssColor(background);\n\n                // Algorithm from \"http://www.w3.org/TR/WCAG20-GENERAL/G18.html\".\n                if (lum1 > lum2) {\n                    ratio = (lum1 + 0.05) / (lum2 + 0.05);\n                } else {\n                    ratio = (lum2 + 0.05) / (lum1 + 0.05);\n                }\n\n                if (ratio <= 4.5) {\n                    window.console.log(`\n                        Contrast ratio is too low: ${ratio}\n                        Colour 1: ${foreground}\n                        Colour 2: ${background}\n                        Luminance 1: ${lum1}\n                        Luminance 2: ${lum2}\n                    `);\n\n                    // We only want the highest node with dodgy contrast reported.\n                    let i = 0;\n                    let found = false;\n                    for (i = 0; i < problemNodes.length; i++) {\n                        if (node.parentElement.indexOf(problemNodes[i]) !== -1) {\n                            found = true;\n                            break;\n                        } else if (problemNodes[i].parentElement.indexOf(node) !== -1) {\n                            problemNodes[i] = node;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        problemNodes.push(node);\n                    }\n                }\n            }\n            index += 1;\n        });\n        return problemNodes;\n    };\n\n    /**\n     * Check accessiblity issue only for table with merged celss.\n     *\n     * @method checkTableMergedCells\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkTableMergedCells = () => {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select('table').forEach(table => {\n            table.setAttribute('nodeId', index);\n            let rowcolspan = table.querySelectorAll('[colspan], [rowspan]');\n            if (rowcolspan.length > 0) {\n                problemNodes.push(table);\n            }\n            index += 1;\n        });\n        return problemNodes;\n    };\n\n    /**\n     * Check accessiblity issue only for table with no headers.\n     *\n     * @method checkTableHeaders\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkTableHeaders = () => {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select('table').forEach(function(table) {\n            table.setAttribute('nodeId', index);\n            if (table.querySelectorAll('tr, td')) {\n                table.querySelectorAll('tr').forEach(row => {\n                    let header = row.querySelector('th');\n                    if (!header || (header.textContent.trim() === '')) {\n                        problemNodes.push(table);\n                    }\n                });\n            } else {\n                let hasHeader = false;\n                table.querySelector('tr').querySelectorAll('th').some(header => {\n                    hasHeader = true;\n                    if (header.textContent.trim() === '') {\n                        problemNodes.push(table);\n                        return true;\n                    }\n                    return false;\n                });\n                if (!hasHeader) {\n                    problemNodes.push(table);\n                }\n            }\n            index += 1;\n        });\n        return problemNodes;\n    };\n\n    /**\n     * Generate the HTML that lists the found warnings.\n     *\n     * @method addWarnings\n     * @param {String} description Description of this failure.\n     * @param {array} nodes An array of failing nodes.\n     * @param {boolean} imagewarnings true if the warnings are related to images, false if text.\n     */\n    addWarnings = async(description, nodes, imagewarnings) => {\n        if (nodes.length > 0) {\n            let text, img;\n            let faillist = '';\n            for (let i = 0; i < nodes.length; i++) {\n                if (imagewarnings) {\n                    img = nodes[i].getAttribute('src');\n                } else {\n                    if ('innerText' in nodes[i]) {\n                        text = nodes[i].innerText.trim();\n                    } else if ('textContent' in nodes[i]) {\n                        text = nodes[i].textContent.trim();\n                    }\n\n                    if (text === '') {\n                        text = await getString('emptytext', component);\n                    }\n\n                    if (nodes[i] === this.editor) {\n                        text = await getString('entiredocument', component);\n                        const parentnode = nodes[i].dom.select('body')[0].childNodes;\n                        let nodelist = '';\n                        parentnode.forEach(childnode => {\n                            if (nodelist === '') {\n                                nodelist += childnode.nodeName.toLowerCase();\n                            } else {\n                                nodelist += ',' + childnode.nodeName.toLowerCase();\n                            }\n                        });\n                        nodes[i] = nodelist;\n                    }\n                    text = text ?? nodes[i].nodeName;\n                }\n\n                faillist += await Templates.render('tiny_accessibilitychecker/list', {\n                    sourceNode: typeof nodes[i] === 'string' ? nodes[i] : nodes[i].nodeName.toLowerCase(),\n                    nodeId: nodes[i].getAttribute('nodeId'),\n                    text: text,\n                    img: img\n                });\n            }\n\n            return await Templates.render('tiny_accessibilitychecker/warning', {\n                html: faillist,\n                description: description\n            });\n        }\n        return '';\n    };\n\n    /**\n     * Convert a CSS color to a luminance value.\n     *\n     * @method getLuminanceFromCssColor\n     * @param {String} colortext The Hex value for the colour\n     * @return {Number} The luminance value.\n     * @private\n     */\n    getLuminanceFromCssColor = (colortext) => {\n        let color;\n\n        if (colortext === 'transparent') {\n            colortext = '#ffffff';\n        }\n        color = this.colorBase.toArray(this.colorBase.toRGB(colortext));\n\n        // Algorithm from \"http://www.w3.org/TR/WCAG20-GENERAL/G18.html\".\n        let part1 = function(a) {\n            a = parseInt(a, 10) / 255.0;\n            if (a <= 0.03928) {\n                a = a / 12.92;\n            } else {\n                a = Math.pow(((a + 0.055) / 1.055), 2.4);\n            }\n            return a;\n        };\n\n        let r1 = part1(color[0]),\n            g1 = part1(color[1]),\n            b1 = part1(color[2]);\n\n        return 0.2126 * r1 + 0.7152 * g1 + 0.0722 * b1;\n    };\n\n    /**\n     * Get the computed RGB converted to full alpha value, considering the node hierarchy.\n     *\n     * @method getComputedBackgroundColor\n     * @param {Node} node\n     * @param {String} color The initial colour. If not specified, fetches the backgroundColor from the node.\n     * @return {Array} Colour in Array form (RGBA)\n     * @private\n     */\n    getComputedBackgroundColor = (node, color) => {\n        color = color ? color : window.getComputedStyle(node, null).getPropertyValue('background-color');\n        if (color.toLowerCase() === 'transparent') {\n            color = 'rgba(1, 1, 1, 0)';\n        }\n\n        // Convert the colour to its constituent parts in RGBA format, then fetch the alpha.\n        let colorParts = this.colorBase.toArray(color);\n        let alpha = colorParts[3];\n\n        if (alpha === 1) {\n            // If the alpha of the background is already 1, then the parent background colour does not change anything.\n            return colorParts;\n        }\n\n        // Fetch the computed background colour of the parent and use it to calculate the RGB of this item.\n        let parentColor = this.getComputedBackgroundColor(node.parentNode);\n        return [\n            // RGB = (alpha * R|G|B) + (1 - alpha * solid parent colour).\n            (1 - alpha) * parentColor[0] + alpha * colorParts[0],\n            (1 - alpha) * parentColor[1] + alpha * colorParts[1],\n            (1 - alpha) * parentColor[2] + alpha * colorParts[2],\n            // We always return a colour with full alpha.\n            1\n        ];\n    };\n};\n"],"names":["constructor","editor","async","this","setSelectedNode","Modal","create","type","types","DEFAULT","large","title","component","body","getDialogueContent","then","modal","getRoot","on","ModalEvents","hidden","selectedNode","includes","nodeName","selectAndScroll","dom","select","focus","destroy","show","catch","selection","getNode","textContent","_this$selectedNode5","hasAttribute","checkAll","checkConfirmation","content","Templates","render","warning","getWarnings","parsedHtml","parseHtml","setSelection","html","DOMParser","parseFromString","firstElementChild","querySelectorAll","forEach","anchor","addEventListener","e","preventDefault","node","currentTarget","getAttribute","nodeId","closeModal","scrollIntoView","behavior","block","list","selectedNodeName","toLowerCase","imagesmissingalt","addWarnings","checkImage","needsmorecontrast","checkOtherElements","getContent","format","length","needsmoreheadings","tablesmissingcaption","checkTableCaption","tableswithmergedcells","checkTableMergedCells","tablesmissingheaders","checkTableHeaders","message","problemNodes","index","img","setAttribute","alt","push","table","caption","querySelector","trim","foreground","background","ratio","lum1","lum2","colorBase","fromArray","getComputedBackgroundColor","window","getComputedStyle","getPropertyValue","TYPES","RGBA","getLuminanceFromCssColor","console","log","i","found","parentElement","indexOf","row","header","hasHeader","some","description","nodes","imagewarnings","text","faillist","innerText","parentnode","childNodes","nodelist","childnode","sourceNode","colortext","color","toArray","toRGB","part1","a","parseInt","Math","pow","colorParts","alpha","parentColor","parentNode","ColorBase"],"mappings":"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"}