{"version":3,"file":"checker.min.js","sources":["../src/checker.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/*\n * @package    tiny_accessibilitychecker\n * @copyright  2022, Stevani Andolo  <stevani@hotmail.com.au>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport {get_string as getString} from 'core/str';\nimport {saveCancelPromise} from 'core/notification';\nimport {component} from './common';\nimport * as Modal from 'core/modal_factory';\nimport * as ModalEvents from 'core/modal_events';\nimport {ColorBase} from './colorbase';\n\nexport default class {\n\n    constructor(editor) {\n        this.editor = editor;\n        this.colorBase = new ColorBase();\n        this.selectedNode = null;\n        this.modal = null;\n    }\n\n    async displayDialogue() {\n        await this.setSelectedNode();\n        Modal.create({\n            type: Modal.types.DEFAULT,\n            large: true,\n            title: getString('pluginname', component),\n            body: this.getDialogueContent()\n        }).then(modal => {\n            this.modal = modal;\n            modal.getRoot().on(ModalEvents.hidden, () => {\n                if (!this.selectedNode || (this.selectedNode && !['TD', 'TABLE'].includes(this.selectedNode.nodeName))) {\n                    if (this.selectedNode) {\n                        this.selectAndScroll(this.selectedNode);\n                    }\n                    this.editor.dom.select('body')[0].focus();\n                }\n                modal.destroy();\n                this.selectedNode = null;\n            });\n            modal.show();\n            return modal;\n        }).catch();\n    }\n\n    /**\n     * Set selected node if any has been selected.\n     *\n     * @method setSelectedNode\n     * @return {boolean} The content to place in the dialogue.\n     */\n    async setSelectedNode() {\n        const selectedNode = this.editor.selection.getNode();\n\n        // Set the selected node if the current selected node is not 'body'.\n        if (selectedNode.nodeName !== 'BODY') {\n            this.selectedNode = selectedNode;\n        }\n\n        // Set the selected node to null if:\n        // 1. Selected node name is 'p' and is empty,\n        // 2. Or selected node name is 'br',\n        // 3. Or selected node name is 'br' and has 'data-mce-bogus' attribute.\n        if (this.selectedNode?.nodeName === 'P' && this.selectedNode?.textContent === '' ||\n            this.selectedNode?.nodeName === 'BR' ||\n            this.selectedNode?.nodeName === 'BR' && this.selectedNode?.hasAttribute('data-mce-bogus')) {\n            this.selectedNode = null;\n        }\n\n        // Set selected node to null if user chose 'Yes' from the confirmation.\n        if (this.selectedNode) {\n            const checkAll = await this.checkConfirmation();\n            this.selectedNode = checkAll ? null : this.selectedNode;\n        }\n    }\n\n    /**\n     * Confirm whether the user wants to do the accessibility check on selected element or everything.\n     *\n     * @returns {Promise<boolean>} Whether the user confirmed the check.\n     */\n    async checkConfirmation() {\n        try {\n            await saveCancelPromise(\n                await getString(\"check_title\", component),\n                await getString(\"check_desc\", component),\n                await getString(\"confirm_yes\", component)\n            );\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Return the dialogue content.\n     *\n     * @method getDialogueContent\n     * @return {Node} The content to place in the dialogue.\n     */\n     async getDialogueContent() {\n        let currentdesc = '';\n        let warnings = [];\n        this.getWarnings().map(async(top) => {\n            let object = [];\n            top.map(async(warning) => {\n                if (warning.key?.includes(':stringlang')) {\n                    warning.key = warning.key.split(':stringlang')[0];\n                }\n                currentdesc = (currentdesc === warning.key) ? currentdesc : warning.key;\n\n                if (warning.text?.includes(':stringlang')) {\n                    warning.text = await getString(warning.text.split(':stringlang')[0], component);\n                }\n                object.push(warning);\n            });\n            warnings.push({'description': await getString(currentdesc, component), 'dataobject': object});\n        });\n\n        const content = await Templates.render('tiny_accessibilitychecker/warning_content', {\n            data: warnings\n        });\n\n        const parsedHtml = this.parseHtml(content);\n        this.setSelection(parsedHtml);\n        return parsedHtml;\n    }\n\n    /**\n     * Parsed string of htmls into html elements.\n     *\n     * @method parseHtml\n     * @param {html} html\n     * @return {node} parsed html\n     */\n    parseHtml(html) {\n        var parser = new DOMParser();\n        var doc = parser.parseFromString(html, 'text/html');\n        return doc.body.firstElementChild;\n    }\n\n    /**\n     * Add listerner to every anchor to perform a selection.\n     *\n     * @method setSelection\n     * @param {content} content\n     */\n    setSelection(content) {\n        content.querySelectorAll('a').forEach(anchor => {\n            anchor.addEventListener('click', (e) => {\n                e.preventDefault();\n                const node = e.currentTarget.getAttribute('sourceNode');\n                let nodeId = e.currentTarget.getAttribute('nodeId');\n                nodeId = (nodeId === 'null') ? 0 : nodeId;\n\n                if (node) {\n                    if (node.includes(',') || node === 'body') {\n                        this.selectAndScroll(this.editor.dom.select('body')[0]);\n                    } else {\n                        this.selectAndScroll(this.editor.dom.select(node)[nodeId]);\n                    }\n                }\n                this.closeModal();\n            });\n        });\n    }\n\n    /**\n     * Set the selection and scroll to the selected element.\n     *\n     * @method selectAndScroll\n     * @param {Node} node\n     */\n    selectAndScroll(node) {\n        this.selectedNode = node;\n        this.editor.selection.select(node).scrollIntoView({\n            behavior: 'smooth', block: 'nearest'\n        });\n    }\n\n    /**\n     * Close current modal.\n     *\n     * @method closeModal\n     */\n    closeModal() {\n        this.modal.destroy();\n    }\n\n    /**\n     * Find all problems with the content editable region.\n     *\n     * @method getWarnings\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    getWarnings() {\n        let warnings = [];\n        let selectedNodeName = this.selectedNode ? this.selectedNode.nodeName.toLowerCase() : null;\n        selectedNodeName = selectedNodeName === 'td' ? 'table' : selectedNodeName;\n\n        // Check Images with no alt text or dodgy alt text.\n        if (selectedNodeName === null || selectedNodeName === 'img') {\n            const warning = this.createWarning('imagesmissingalt', this.checkImage(), true);\n            if (warning.length > 0) {\n                warnings.push(warning);\n            }\n        }\n\n        if (selectedNodeName === null || (selectedNodeName !== 'img' && selectedNodeName !== 'table')) {\n            const warning = this.createWarning('needsmorecontrast', this.checkOtherElements(selectedNodeName), false);\n            if (warning.length > 0) {\n                warnings.push(warning);\n            }\n        }\n\n        // Check for no headings.\n        if (this.editor.getContent({format: 'text'}).length > 1000 && this.editor.dom.select('h3,h4,h5').length < 1) {\n            const warning = this.createWarning('needsmoreheadings', [this.editor], false);\n            if (warning.length > 0) {\n                warnings.push(warning);\n            }\n        }\n\n        if (selectedNodeName === null || selectedNodeName === 'table') {\n            // Check for tables with no captions.\n            let warning = this.createWarning('tablesmissingcaption', this.checkTableCaption(), false);\n            if (warning.length > 0) {\n                warnings.push(warning);\n            }\n\n            // Check for tables with merged cells.\n            warning = this.createWarning('tableswithmergedcells', this.checkTableMergedCells(), false);\n            if (warning.length > 0) {\n                warnings.push(warning);\n            }\n\n            // Check for tables with no row/col headers.\n            warning = this.createWarning('tablesmissingheaders', this.checkTableHeaders(), false);\n            if (warning.length > 0) {\n                warnings.push(warning);\n            }\n        }\n\n        if (warnings.length < 1) {\n            warnings.push([{\n                key: this.selectedNode ? 'nowarningonselected:stringlang' : 'nowarnings:stringlang',\n                nowarning: true\n            }]);\n        }\n        return warnings;\n    }\n\n    /**\n     * Generate the HTML that lists the found warnings.\n     *\n     * @method createWarning\n     * @param {String} description Description of this failure.\n     * @param {array} nodes An array of failing nodes.\n     * @param {boolean} imagewarnings true if the warnings are related to images, false if text.\n     * @return {array} array of objects\n     */\n    createWarning(description, nodes, imagewarnings) {\n        let warnings = [];\n        let text, src;\n        for (let i = 0; i < nodes.length; i++) {\n            if (imagewarnings) {\n                src = nodes[i].getAttribute('src');\n            } else {\n                if ('innerText' in nodes[i]) {\n                    text = nodes[i].innerText.trim();\n                } else if ('textContent' in nodes[i]) {\n                    text = nodes[i].textContent.trim();\n                }\n\n                if (text === '') {\n                    text = 'emptytext:stringlang';\n                }\n\n                if (nodes[i] === this.editor) {\n                    text = 'entiredocument:stringlang';\n                    const childnodes = nodes[i].dom.select('body')[0].childNodes;\n                    if (childnodes.length > 1) {\n                        nodes[i] = 'body';\n                    } else {\n                        nodes[i] = childnodes.nodeName.toLowerCase();\n                    }\n                }\n                text = text ?? nodes[i].nodeName;\n            }\n            warnings.push({\n                key: description,\n                sourceNode: (typeof nodes[i] === 'string') ? nodes[i] : nodes[i].nodeName.toLowerCase(),\n                nodeId: nodes[i].getAttribute('nodeId'),\n                text: text,\n                img: src\n            });\n        }\n        return warnings;\n    }\n\n    /**\n     * Check accessiblity issue only for img type.\n     *\n     * @method checkImage\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkImage() {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select('img').forEach(img => {\n            img.setAttribute('nodeId', index);\n            let alt = img.getAttribute('alt');\n            if (typeof alt === 'undefined' || alt === '' || alt === null) {\n                if (img.getAttribute('role') !== 'presentation') {\n                    problemNodes.push(img);\n                }\n            }\n            index += 1;\n        });\n        return problemNodes;\n    }\n\n    /**\n     * Check accessiblity issue only for table with no caption.\n     *\n     * @method checkTableCaption\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkTableCaption() {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select('table').forEach(function(table) {\n            table.setAttribute('nodeId', index);\n            let caption = table.querySelector('caption');\n            if (caption === null || caption.textContent.trim() === '') {\n                problemNodes.push(table);\n            }\n            index += 1;\n        });\n        return problemNodes;\n    }\n\n    /**\n     * Check accessiblity issue for not img and table only.\n     *\n     * @method checkOtherElements\n     * @param {node} node\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkOtherElements(node) {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select(node ?? 'body').forEach(node => {\n            node.setAttribute('nodeId', index);\n            let foreground,\n                background,\n                ratio,\n                lum1,\n                lum2;\n\n            // Check for non-empty text.\n            if (node.textContent.trim() !== '') {\n                foreground = this.colorBase.fromArray(\n                    this.getComputedBackgroundColor(\n                        node,\n                        window.getComputedStyle(node, null).getPropertyValue('color')\n                    ),\n                    this.colorBase.TYPES.RGBA\n                );\n                background = this.colorBase.fromArray(\n                    this.getComputedBackgroundColor(\n                        node\n                    ),\n                    this.colorBase.TYPES.RGBA\n                );\n\n                lum1 = this.getLuminanceFromCssColor(foreground);\n                lum2 = this.getLuminanceFromCssColor(background);\n\n                // Algorithm from \"http://www.w3.org/TR/WCAG20-GENERAL/G18.html\".\n                if (lum1 > lum2) {\n                    ratio = (lum1 + 0.05) / (lum2 + 0.05);\n                } else {\n                    ratio = (lum2 + 0.05) / (lum1 + 0.05);\n                }\n\n                if (ratio <= 4.5) {\n                    window.console.log(`\n                        Contrast ratio is too low: ${ratio}\n                        Colour 1: ${foreground}\n                        Colour 2: ${background}\n                        Luminance 1: ${lum1}\n                        Luminance 2: ${lum2}\n                    `);\n\n                    // We only want the highest node with dodgy contrast reported.\n                    let i = 0;\n                    let found = false;\n                    for (i = 0; i < problemNodes.length; i++) {\n                        if (node.parentElement.indexOf(problemNodes[i]) !== -1) {\n                            found = true;\n                            break;\n                        } else if (problemNodes[i].parentElement.indexOf(node) !== -1) {\n                            problemNodes[i] = node;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        problemNodes.push(node);\n                    }\n                }\n            }\n            index += 1;\n        });\n        return problemNodes;\n    }\n\n    /**\n     * Check accessiblity issue only for table with merged celss.\n     *\n     * @method checkTableMergedCells\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkTableMergedCells() {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select('table').forEach(table => {\n            table.setAttribute('nodeId', index);\n            let rowcolspan = table.querySelectorAll('[colspan], [rowspan]');\n            if (rowcolspan.length > 0) {\n                problemNodes.push(table);\n            }\n            index += 1;\n        });\n        return problemNodes;\n    }\n\n    /**\n     * Check accessiblity issue only for table with no headers.\n     *\n     * @method checkTableHeaders\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkTableHeaders() {\n        let problemNodes = [],\n            index = 0;\n        this.editor.dom.select('table').forEach(function(table) {\n            table.setAttribute('nodeId', index);\n            if (table.querySelectorAll('tr, td')) {\n                table.querySelectorAll('tr').forEach(row => {\n                    let header = row.querySelector('th');\n                    if (!header || (header.textContent.trim() === '')) {\n                        problemNodes.push(table);\n                    }\n                });\n            } else {\n                let hasHeader = false;\n                table.querySelector('tr').querySelectorAll('th').some(header => {\n                    hasHeader = true;\n                    if (header.textContent.trim() === '') {\n                        problemNodes.push(table);\n                        return true;\n                    }\n                    return false;\n                });\n                if (!hasHeader) {\n                    problemNodes.push(table);\n                }\n            }\n            index += 1;\n        });\n        return problemNodes;\n    }\n\n    /**\n     * Convert a CSS color to a luminance value.\n     *\n     * @method getLuminanceFromCssColor\n     * @param {String} colortext The Hex value for the colour\n     * @return {Number} The luminance value.\n     * @private\n     */\n    getLuminanceFromCssColor(colortext) {\n        let color;\n\n        if (colortext === 'transparent') {\n            colortext = '#ffffff';\n        }\n        color = this.colorBase.toArray(this.colorBase.toRGB(colortext));\n\n        // Algorithm from \"http://www.w3.org/TR/WCAG20-GENERAL/G18.html\".\n        let part1 = function(a) {\n            a = parseInt(a, 10) / 255.0;\n            if (a <= 0.03928) {\n                a = a / 12.92;\n            } else {\n                a = Math.pow(((a + 0.055) / 1.055), 2.4);\n            }\n            return a;\n        };\n\n        let r1 = part1(color[0]),\n            g1 = part1(color[1]),\n            b1 = part1(color[2]);\n\n        return 0.2126 * r1 + 0.7152 * g1 + 0.0722 * b1;\n    }\n\n    /**\n     * Get the computed RGB converted to full alpha value, considering the node hierarchy.\n     *\n     * @method getComputedBackgroundColor\n     * @param {Node} node\n     * @param {String} color The initial colour. If not specified, fetches the backgroundColor from the node.\n     * @return {Array} Colour in Array form (RGBA)\n     * @private\n     */\n    getComputedBackgroundColor(node, color) {\n        color = color ? color : window.getComputedStyle(node, null).getPropertyValue('background-color');\n        if (color.toLowerCase() === 'transparent') {\n            color = 'rgba(1, 1, 1, 0)';\n        }\n\n        // Convert the colour to its constituent parts in RGBA format, then fetch the alpha.\n        let colorParts = this.colorBase.toArray(color);\n        let alpha = colorParts[3];\n\n        if (alpha === 1) {\n            // If the alpha of the background is already 1, then the parent background colour does not change anything.\n            return colorParts;\n        }\n\n        // Fetch the computed background colour of the parent and use it to calculate the RGB of this item.\n        let parentColor = this.getComputedBackgroundColor(node.parentNode);\n        return [\n            // RGB = (alpha * R|G|B) + (1 - alpha * solid parent colour).\n            (1 - alpha) * parentColor[0] + alpha * colorParts[0],\n            (1 - alpha) * parentColor[1] + alpha * colorParts[1],\n            (1 - alpha) * parentColor[2] + alpha * colorParts[2],\n            // We always return a colour with full alpha.\n            1\n        ];\n    }\n}\n"],"names":["constructor","editor","colorBase","ColorBase","selectedNode","modal","this","setSelectedNode","Modal","create","type","types","DEFAULT","large","title","component","body","getDialogueContent","then","getRoot","on","ModalEvents","hidden","includes","nodeName","selectAndScroll","dom","select","focus","destroy","show","catch","selection","getNode","textContent","_this$selectedNode5","hasAttribute","checkAll","checkConfirmation","currentdesc","warnings","getWarnings","map","async","object","top","warning","key","_warning$key","split","text","_warning$text","push","content","Templates","render","data","parsedHtml","parseHtml","setSelection","html","DOMParser","parseFromString","firstElementChild","querySelectorAll","forEach","anchor","addEventListener","e","preventDefault","node","currentTarget","getAttribute","nodeId","closeModal","scrollIntoView","behavior","block","selectedNodeName","toLowerCase","createWarning","checkImage","length","checkOtherElements","getContent","format","checkTableCaption","checkTableMergedCells","checkTableHeaders","nowarning","description","nodes","imagewarnings","src","i","innerText","trim","childnodes","childNodes","sourceNode","img","problemNodes","index","setAttribute","alt","table","caption","querySelector","foreground","background","ratio","lum1","lum2","fromArray","getComputedBackgroundColor","window","getComputedStyle","getPropertyValue","TYPES","RGBA","getLuminanceFromCssColor","console","log","found","parentElement","indexOf","row","header","hasHeader","some","colortext","color","toArray","toRGB","part1","a","parseInt","Math","pow","colorParts","alpha","parentColor","parentNode"],"mappings":"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"}