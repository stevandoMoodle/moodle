{"version":3,"file":"base.min.js","sources":["../../src/bibliography/base.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/*\n * @package    tiny_bibliography\n * @copyright  2023 Stevani Andolo <stevani@hotmail.com.au>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport {alert} from 'core/notification';\nimport {get_string as getString} from 'core/str';\nimport {component} from '../common';\nimport {\n    byId,\n    getInTextRefNumber,\n    getTextNodes,\n    lcFirst\n} from './helper';\nimport {getBioContent} from './templateloader';\n\nexport default class Base {\n    /**\n     * Cite in a bibliography.\n     *\n     * @param {object} bio\n     * @param {event} event\n     */\n    citeThis = async(bio, event) => {\n        const cite = event.target.closest('[data-action=\"cite-this\"]');\n        const list = bio.editor.dom.select(`[class=\"${cite.dataset.id}\"]`);\n        const index = cite.dataset.index;\n        if (list) {\n            bio.editor.insertContent(\n                await Templates.render('tiny_bibliography/bibliography_citation', {\n                    index: index\n                })\n            );\n            bio.modal.hide();\n        }\n    };\n\n    /**\n     * Delete a citation.\n     *\n     * @param {object} bio\n     * @param {event} event\n     */\n    deleteBibliography = (bio, event) => {\n        const deleteBio = event.target.closest('[data-action=\"delete-bio\"]');\n        const list = bio.editor.dom.select(`[class=\"${deleteBio.dataset.id}\"]`);\n        const index = parseInt(deleteBio.dataset.index);\n        if (list) {\n            const refNo = bio.editor.dom.select(`[class=\"cited-bibliography\"]`);\n            refNo.forEach(ref => {\n                const text = getInTextRefNumber(ref);\n                if (parseInt(text) === index) {\n                    // Delete citation(s) if data-index is the same as current text of it.\n                    ref.remove();\n                }\n            });\n\n            // Delete found bibliography list.\n            list[0].remove();\n\n            // Close the modal.\n            bio.modal.hide();\n        }\n    };\n\n    /**\n     * Edit bibliography list.\n     *\n     * @param {object} bio\n     * @param {Element} editBio\n     */\n    editBibliography = async(bio, editBio) => {\n        const allData = JSON.parse(editBio.dataset.object);\n\n        // Sets selected style and source.\n        bio.setStyle(allData.style);\n        await bio.setSource(allData.source);\n\n        for (const key in allData) {\n            const keyId = lcFirst(key.replaceAll('pure', ''));\n            const id = `id_bibliography_${keyId}`;\n            if (byId(id)) {\n                byId(id).value = allData[key];\n            }\n\n            const otherFields = byId('id_other_fields');\n            if (keyId === 'showOtherFields' && allData[key] === 'true' && !bio.allData.showOtherFields && otherFields) {\n                otherFields.click();\n            } else {\n                bio.allData[key] = allData[key];\n            }\n        }\n\n        bio.create = false;\n        bio.updateId = editBio.dataset.id;\n        bio.updateIndex = editBio.dataset.index;\n\n        byId('id-generate-label').textContent = await getString('update', component);\n    };\n\n    getRequiredFields = (bio) => {\n        let fields = [];\n        bio.fields.forEach(field => {\n            if (field.required) {\n                fields.push(field.field);\n            }\n        });\n        return fields;\n    };\n\n    createKeyValuePair = (bio) => {\n        let keyValuePair = '';\n        for (const key in bio.allData) {\n            if (key !== 'keyValuePair') {\n                if (keyValuePair === '') {\n                    keyValuePair += `\"${key}\": \"${bio.allData[key]}\"`;\n                } else {\n                    keyValuePair += `, \"${key}\": \"${bio.allData[key]}\"`;\n                }\n            }\n        }\n        bio.allData.keyValuePair = keyValuePair;\n    };\n\n    checkRequiredFields = (bio) => {\n        // Concat author, style and source to requiredFields.\n        const fields = [\n            'style',\n            'source'\n        ].concat(this.getRequiredFields(bio));\n\n        let i = 0;\n        fields.every(field => {\n            if (!bio.allData[field] || bio.allData[field] === '') {\n                return false;\n            }\n            i++;\n            return true;\n        });\n\n        this.createKeyValuePair(bio);\n        return (i === fields.length);\n    };\n\n    /**\n     * Generates or updates the bibliography.\n     *\n     * @param {object} bio\n     */\n    generateBibliography = async(bio) => {\n        if (this.checkRequiredFields(bio)) {\n            if (bio.create) {\n                let bioList = bio.editor.dom.select('[class=\"id-bibliography-holder\"]'),\n                index = bioList.length;\n                if (index > 0) {\n                    index = bioList[0].querySelectorAll('p').length;\n                }\n\n                bio.updateIndex = index + 1;\n                const info = await getBioContent(bio);\n                let bibliography;\n                let textNodes;\n                if (index > 0) {\n                    textNodes = getTextNodes(bioList[0].lastChild);\n                    bibliography = info;\n                } else {\n                    textNodes = getTextNodes(bio.editor.getBody().lastChild);\n                    bibliography = await Templates.render('tiny_bibliography/bibliography_header', {\n                        info: info\n                    });\n                }\n\n                const currentElement = bio.editor.selection.getNode().getAttribute('class');\n                if (currentElement && currentElement.includes('id-bibliography-list-')) {\n                    // Put the cursor to the end of the selected bio element.\n                    textNodes = getTextNodes(bio.editor.selection.getNode());\n                }\n\n                // Locate to insert a new bio.\n                bio.editor.selection.setCursorLocation(\n                    textNodes[textNodes.length - 1],\n                    textNodes[textNodes.length - 1].textContent.length\n                );\n\n                // Insert new bio list.\n                await bio.editor.insertContent(bibliography);\n            } else {\n                const targetList = bio.editor.dom.select(`[class=\"${bio.updateId}\"]`)[0];\n                targetList.innerHTML = await getBioContent(bio);\n                bio.create = true;\n            }\n\n            // Close the modal.\n            bio.modal.hide();\n        } else {\n            alert('Error!', 'You need to provide all information');\n        }\n    };\n\n    getTextNodes = (node, nodeType, result) => {\n        var children = node.childNodes;\n        var nodeType = nodeType ? nodeType : 3;\n\n        var result = !result ? [] : result;\n        if (node.nodeType == nodeType) {\n            result.push(node);\n        }\n\n        for (var i = 0; i < children.length; i++) {\n            result = this.getTextNodes(children[i], nodeType, result);\n        }\n\n        return result;\n    };\n\n    scrollToBottom = (bio) => {\n        bio.editor.dom.select('[id=\"bibliography-container\"]')[0].scrollIntoView({\n            behavior: 'smooth',\n            block: 'nearest'\n        });\n    };\n}\n"],"names":["async","bio","event","cite","target","closest","list","editor","dom","select","dataset","id","index","insertContent","Templates","render","modal","hide","deleteBio","parseInt","forEach","ref","text","remove","editBio","allData","JSON","parse","object","setStyle","style","setSource","source","key","keyId","replaceAll","value","otherFields","showOtherFields","click","create","updateId","updateIndex","textContent","component","fields","field","required","push","keyValuePair","concat","this","getRequiredFields","i","every","createKeyValuePair","length","checkRequiredFields","bioList","querySelectorAll","info","bibliography","textNodes","lastChild","getBody","currentElement","selection","getNode","getAttribute","includes","setCursorLocation","innerHTML","node","nodeType","result","children","childNodes","getTextNodes","scrollIntoView","behavior","block"],"mappings":"4mBAwCeA,MAAMC,IAAKC,eACZC,KAAOD,MAAME,OAAOC,QAAQ,6BAC5BC,KAAOL,IAAIM,OAAOC,IAAIC,yBAAkBN,KAAKO,QAAQC,UACrDC,MAAQT,KAAKO,QAAQE,MACvBN,OACAL,IAAIM,OAAOM,oBACDC,mBAAUC,OAAO,0CAA2C,CAC9DH,MAAOA,SAGfX,IAAIe,MAAMC,sDAUG,CAAChB,IAAKC,eACjBgB,UAAYhB,MAAME,OAAOC,QAAQ,8BACjCC,KAAOL,IAAIM,OAAOC,IAAIC,yBAAkBS,UAAUR,QAAQC,UAC1DC,MAAQO,SAASD,UAAUR,QAAQE,UACrCN,KAAM,CACQL,IAAIM,OAAOC,IAAIC,uCACvBW,SAAQC,YACJC,MAAO,8BAAmBD,KAC5BF,SAASG,QAAUV,OAEnBS,IAAIE,YAKZjB,KAAK,GAAGiB,SAGRtB,IAAIe,MAAMC,oDAUCjB,MAAMC,IAAKuB,iBACpBC,QAAUC,KAAKC,MAAMH,QAAQd,QAAQkB,QAG3C3B,IAAI4B,SAASJ,QAAQK,aACf7B,IAAI8B,UAAUN,QAAQO,YAEvB,MAAMC,OAAOR,QAAS,OACjBS,OAAQ,mBAAQD,IAAIE,WAAW,OAAQ,KACvCxB,6BAAwBuB,QAC1B,gBAAKvB,uBACAA,IAAIyB,MAAQX,QAAQQ,YAGvBI,aAAc,gBAAK,mBACX,oBAAVH,OAAgD,SAAjBT,QAAQQ,OAAoBhC,IAAIwB,QAAQa,iBAAmBD,YAC1FA,YAAYE,QAEZtC,IAAIwB,QAAQQ,KAAOR,QAAQQ,KAInChC,IAAIuC,QAAS,EACbvC,IAAIwC,SAAWjB,QAAQd,QAAQC,GAC/BV,IAAIyC,YAAclB,QAAQd,QAAQE,uBAE7B,qBAAqB+B,kBAAoB,mBAAU,SAAUC,gEAGjD3C,UACb4C,OAAS,UACb5C,IAAI4C,OAAOzB,SAAQ0B,QACXA,MAAMC,UACNF,OAAOG,KAAKF,MAAMA,UAGnBD,qDAGW5C,UACdgD,aAAe,OACd,MAAMhB,OAAOhC,IAAIwB,QACN,iBAARQ,MAEIgB,cADiB,KAAjBA,wBACoBhB,mBAAUhC,IAAIwB,QAAQQ,uBAEpBA,mBAAUhC,IAAIwB,QAAQQ,WAIxDhC,IAAIwB,QAAQwB,aAAeA,4DAGRhD,YAEb4C,OAAS,CACX,QACA,UACFK,OAAOC,KAAKC,kBAAkBnD,UAE5BoD,EAAI,SACRR,OAAOS,OAAMR,UACJ7C,IAAIwB,QAAQqB,QAAiC,KAAvB7C,IAAIwB,QAAQqB,UAGvCO,KACO,UAGNE,mBAAmBtD,KAChBoD,IAAMR,OAAOW,uDAQFxD,MAAAA,SACfmD,KAAKM,oBAAoBxD,KAAM,IAC3BA,IAAIuC,OAAQ,KACRkB,QAAUzD,IAAIM,OAAOC,IAAIC,OAAO,oCACpCG,MAAQ8C,QAAQF,OACZ5C,MAAQ,IACRA,MAAQ8C,QAAQ,GAAGC,iBAAiB,KAAKH,QAG7CvD,IAAIyC,YAAc9B,MAAQ,QACpBgD,WAAa,iCAAc3D,SAC7B4D,aACAC,UACAlD,MAAQ,GACRkD,WAAY,wBAAaJ,QAAQ,GAAGK,WACpCF,aAAeD,OAEfE,WAAY,wBAAa7D,IAAIM,OAAOyD,UAAUD,WAC9CF,mBAAqB/C,mBAAUC,OAAO,wCAAyC,CAC3E6C,KAAMA,cAIRK,eAAiBhE,IAAIM,OAAO2D,UAAUC,UAAUC,aAAa,SAC/DH,gBAAkBA,eAAeI,SAAS,2BAE1CP,WAAY,wBAAa7D,IAAIM,OAAO2D,UAAUC,YAIlDlE,IAAIM,OAAO2D,UAAUI,kBACjBR,UAAUA,UAAUN,OAAS,GAC7BM,UAAUA,UAAUN,OAAS,GAAGb,YAAYa,cAI1CvD,IAAIM,OAAOM,cAAcgD,kBAC5B,CACgB5D,IAAIM,OAAOC,IAAIC,yBAAkBR,IAAIwC,gBAAc,GAC3D8B,gBAAkB,iCAActE,KAC3CA,IAAIuC,QAAS,EAIjBvC,IAAIe,MAAMC,mCAEJ,SAAU,+EAIT,CAACuD,KAAMC,SAAUC,cACxBC,SAAWH,KAAKI,WAChBH,SAAWA,UAAsB,EAEjCC,OAAUA,QAAS,GACnBF,KAAKC,UAAYA,UACjBC,OAAO1B,KAAKwB,UAGX,IAAInB,EAAI,EAAGA,EAAIsB,SAASnB,OAAQH,IACjCqB,OAASvB,KAAK0B,aAAaF,SAAStB,GAAIoB,SAAUC,eAG/CA,iDAGOzE,MACdA,IAAIM,OAAOC,IAAIC,OAAO,iCAAiC,GAAGqE,eAAe,CACrEC,SAAU,SACVC,MAAO"}