{"version":3,"file":"commonmodule.min.js","sources":["../../src/recording/commonmodule.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny Record RTC Commonmodule values.\n *\n * @module      tiny_recordrtc/commonmodule\n * @copyright   2022 Stevani Andolo <stevani@hotmail.com.au>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {get_string as getString} from 'core/str';\nimport {component} from '../common';\nimport * as AbstractModule from './abstractmodule';\n\nexport const data = {\n    // Unitialized variables to be used by the other modules.\n    editorScope: null,\n    alertWarning: null,\n    alertDanger: null,\n    player: null,\n    playerDOM: null, // Used to manipulate DOM directly.\n    startStopBtn: null,\n    uploadBtn: null,\n    countdownSeconds: null,\n    countdownTicker: null,\n    recType: null,\n    stream: null,\n    mediaRecorder: null,\n    chunks: null,\n    blobSize: null,\n    maxUploadSize: null,\n    audioData: null,\n    modal: null\n};\n\n// Capture webcam/microphone stream.\nexport const captureUserMedia = (mediaConstraints, successCallback, errorCallback) => {\n    navigator.mediaDevices.getUserMedia(mediaConstraints).then(successCallback).catch(errorCallback);\n};\n\n// Add chunks of audio/video to array when made available.\nexport const handleDataAvailable = (event) => {\n    // Push recording slice to array.\n    data.chunks.push(event.data);\n    // Size of all recorded data so far.\n    data.blobSize += event.data.size;\n\n    // If total size of recording so far exceeds max upload limit, stop recording.\n    // An extra condition exists to avoid displaying alert twice.\n    if (data.blobSize >= data.maxUploadSize) {\n        if (!localStorage.getItem('alerted')) {\n            localStorage.setItem('alerted', 'true');\n\n            data.startStopBtn.click();\n            AbstractModule.showAlert('nearingmaxsize');\n        } else {\n            localStorage.removeItem('alerted');\n        }\n\n        data.chunks.pop();\n    }\n};\n\n// Handle recording end.\nexport const handleStop = async() => {\n    const [\n        attachrecording\n    ] = await Promise.all([\n        getString('attachrecording', component)\n    ]);\n\n    // Set source of audio player.\n    var blob = new Blob(data.chunks, {type: data.mediaRecorder.mimeType});\n    data.player.srcObject = null;\n    data.player.src = URL.createObjectURL(blob);\n\n    // Show audio player with controls enabled, and unmute.\n    data.player.muted = false;\n    data.player.controls = true;\n    data.player.parentElement.parentElement.classList.remove('hide');\n\n    // Show upload button.\n    data.uploadBtn.parentElement.parentElement.classList.remove('hide');\n    data.uploadBtn.textContent = attachrecording;\n    data.uploadBtn.disabled = false;\n\n    // Handle when upload button is clicked.\n    data.uploadBtn.addEventListener('click', uploadHandler);\n};\n\n// Handle when upload button is clicked.\nexport const uploadHandler = async() => {\n    const [\n        uploadfailed,\n        uploadfailed404,\n        uploadaborted\n    ] = await Promise.all([\n        getString('uploadfailed', component),\n        getString('uploadfailed404', component),\n        getString('uploadaborted', component)\n    ]);\n\n    // Trigger error if no recording has been made.\n    if (data.chunks.length === 0) {\n        AbstractModule.showAlert('norecordingfound');\n    } else {\n        data.uploadBtn.disabled = true;\n\n        // Upload recording to server.\n        uploadToServer(data.recType, function(progress, fileURLOrError) {\n            if (progress === 'ended') { // Insert annotation in text.\n                data.uploadBtn.disabled = false;\n                insertAnnotation(data.recType, fileURLOrError);\n            } else if (progress === 'upload-failed') { // Show error message in upload button.\n                data.uploadBtn.disabled = false;\n                data.uploadBtn.textContent = `${uploadfailed} ${fileURLOrError}`;\n            } else if (progress === 'upload-failed-404') { // 404 error = File too large in Moodle.\n                data.uploadBtn.disabled = false;\n                data.uploadBtn.textContent = uploadfailed404;\n            } else if (progress === 'upload-aborted') {\n                data.uploadBtn.disabled = false;\n                data.uploadBtn.textContent = `${uploadaborted} ${fileURLOrError}`;\n            } else {\n                data.uploadBtn.textContent = progress;\n            }\n        });\n    }\n};\n\n// Get everything set up to start recording.\nexport const startRecording = async(type, stream) => {\n    const [\n        stoprecording\n    ] = await Promise.all([\n        getString('stoprecording', component)\n    ]);\n\n    // The options for the recording codecs and bitrates.\n    var options = selectRecOptions(type);\n    data.mediaRecorder = new MediaRecorder(stream, options);\n\n    // Initialize MediaRecorder events and start recording.\n    data.mediaRecorder.ondataavailable = handleDataAvailable;\n    data.mediaRecorder.onstop = handleStop;\n    data.mediaRecorder.start(1000); // Capture in 1s chunks. Must be set to work with Firefox.\n\n    // Mute audio, distracting while recording.\n    data.player.muted = true;\n\n    // Set recording timer to the time specified in the settings.\n    if (type === 'audio') {\n        data.countdownSeconds = data.editorScope.audiotimelimit;\n    } else if (type === 'video') {\n        data.countdownSeconds = data.editorScope.videotimelimit;\n    } else {\n        // Default timer.\n        data.countdownSeconds = data.editorScope.defaulttimelimit;\n    }\n    data.countdownSeconds++;\n    var timerText = stoprecording;\n    timerText += ' (<span id=\"minutes\"></span>:<span id=\"seconds\"></span>)';\n    data.startStopBtn.innerHTML = timerText;\n    setTime();\n    data.countdownTicker = setInterval(setTime, 1000);\n\n    // Make button clickable again, to allow stopping recording.\n    data.startStopBtn.disabled = false;\n};\n\nexport let selectRecOptions = (recType) => {\n    var types, options;\n\n    if (recType === 'audio') {\n        types = [\n            'audio/webm;codecs=opus',\n            'audio/ogg;codecs=opus'\n        ];\n        options = {\n            audioBitsPerSecond: parseInt(data.editorScope.audiobitrate)\n        };\n    } else {\n        types = [\n            'video/webm;codecs=vp9,opus',\n            'video/webm;codecs=h264,opus',\n            'video/webm;codecs=vp8,opus'\n        ];\n        options = {\n            audioBitsPerSecond: parseInt(data.editorScope.audiobitrate),\n            videoBitsPerSecond: parseInt(data.editorScope.videobitrate)\n        };\n    }\n\n    var compatTypes = types.filter(function(type) {\n        return MediaRecorder.isTypeSupported(type);\n    });\n\n    if (compatTypes.length !== 0) {\n        options.mimeType = compatTypes[0];\n    }\n\n    return options;\n};\n\n// Upload recorded audio/video to server.\nexport const uploadToServer = (type, callback) => {\n    const xhr = new XMLHttpRequest();\n\n    // Get src media of audio/video tag.\n    xhr.open('GET', data.player.src, true);\n    xhr.responseType = 'blob';\n\n    xhr.addEventListener('load', () => {\n        if (xhr.status === 200) { // If src media was successfully retrieved.\n            // blob is now the media that the audio/video tag's src pointed to.\n            const blob = xhr.response;\n\n            // Generate filename with random ID and file extension.\n            let fileName = (Math.random() * 1000).toString().replace('.', '');\n            fileName += (type === 'audio') ? '-audio.ogg'\n                                           : '-video.webm';\n\n            // Create FormData to send to PHP filepicker-upload script.\n            let formData = new FormData(),\n                filepickerOptions = data.editorScope.filepickeroptions.link,\n                repositoryKeys = Object.keys(filepickerOptions.repositories);\n\n            formData.append('repo_upload_file', blob, fileName);\n            formData.append('itemid', filepickerOptions.itemid);\n\n            for (let i = 0; i < repositoryKeys.length; i++) {\n                if (filepickerOptions.repositories[repositoryKeys[i]].type === 'upload') {\n                    formData.append('repo_id', filepickerOptions.repositories[repositoryKeys[i]].id);\n                    break;\n                }\n            }\n\n            formData.append('env', filepickerOptions.env);\n            formData.append('sesskey', M.cfg.sesskey);\n            formData.append('client_id', filepickerOptions.client_id);\n            formData.append('savepath', '/');\n            formData.append('ctx_id', filepickerOptions.context.id);\n\n            // Pass FormData to PHP script using XHR.\n            const uploadEndpoint = `${M.cfg.wwwroot}/repository/repository_ajax.php?action=upload`;\n            makeXmlhttprequest(uploadEndpoint, formData,\n                function(progress, responseText) {\n                    if (progress === 'upload-ended') {\n                        callback('ended', JSON.parse(responseText).url);\n                    } else {\n                        callback(progress);\n                    }\n                }\n            );\n        }\n    });\n\n    xhr.send();\n};\n\n// Handle XHR sending/receiving/status.\nexport const makeXmlhttprequest = async(url, data, callback) => {\n    const [\n        uploadprogress\n    ] = await Promise.all([\n        getString('uploadprogress', component)\n    ]);\n\n    var xhr = new window.XMLHttpRequest();\n\n    xhr.onreadystatechange = function() {\n        if ((xhr.readyState === 4) && (xhr.status === 200)) { // When request is finished and successful.\n            callback('upload-ended', xhr.responseText);\n        } else if (xhr.status === 404) { // When request returns 404 Not Found.\n            callback('upload-failed-404');\n        }\n    };\n\n    xhr.upload.addEventListener('progress', (e) => {\n        callback(`${Math.round(e.loaded / e.total * 100)}% ${uploadprogress}`);\n    });\n\n    xhr.upload.addEventListener('error', (error) => {\n        callback('upload-failed', error);\n    });\n\n    xhr.upload.addEventListener('abort', (error) => {\n        callback('upload-aborted', error);\n    });\n\n    // POST FormData to PHP script that handles uploading/saving.\n    xhr.open('POST', url, true);\n    xhr.send(data);\n};\n\n// Get everything set up to stop recording.\nexport const stopRecording = (stream) => {\n    // Stop recording stream.\n    data.mediaRecorder.stop();\n\n    // Stop each individual MediaTrack.\n    var tracks = stream.getTracks();\n    for (var i = 0; i < tracks.length; i++) {\n        tracks[i].stop();\n    }\n};\n\n// Makes 1min and 2s display as 1:02 on timer instead of 1:2, for example.\nexport const pad = (val) => {\n    var valString = val + \"\";\n\n    if (valString.length < 2) {\n        return \"0\" + valString;\n    } else {\n        return valString;\n    }\n};\n\n// Functionality to make recording timer count down.\n// Also makes recording stop when time limit is hit.\nexport const setTime = () => {\n    data.countdownSeconds--;\n\n    document.querySelector('span#seconds').textContent = pad(\n        data.countdownSeconds % 60\n    );\n    document.querySelector('span#minutes').textContent = pad(\n        parseInt(data.countdownSeconds / 60, 10)\n    );\n\n    if (data.countdownSeconds === 0) {\n        data.startStopBtn.click();\n    }\n};\n\n// Generates link to recorded annotation to be inserted.\nexport const createAnnotation = (type, recordingurl) => {\n    var html = '';\n    if (type == 'audio') {\n        html = \"<audio controls='true'>\";\n    } else { // Must be video.\n        html = \"<video controls='true'>\";\n    }\n\n    html += `<source src='${recordingurl}'>${recordingurl}`;\n\n    if (type == 'audio') {\n        html += \"</audio>\";\n    } else { // Must be video.\n        html += \"</video>\";\n    }\n\n    return html;\n};\n\n// Inserts link to annotation in editor text area.\nexport const insertAnnotation = async(type, recordingurl) => {\n    const [\n        attachrecording\n    ] = await Promise.all([\n        getString('attachrecording', component)\n    ]);\n\n    var annotation = createAnnotation(type, recordingurl);\n\n    // Insert annotation link.\n    // If user pressed \"Cancel\", just go back to main recording screen.\n    if (!annotation) {\n        data.uploadBtn.textContent = attachrecording;\n    } else {\n        data.audioData = annotation;\n        data.editorScope.editor.insertContent(annotation);\n        data.editorScope.currentModal.destroy();\n    }\n};\n"],"names":["data","editorScope","alertWarning","alertDanger","player","playerDOM","startStopBtn","uploadBtn","countdownSeconds","countdownTicker","recType","stream","mediaRecorder","chunks","blobSize","maxUploadSize","audioData","modal","mediaConstraints","successCallback","errorCallback","navigator","mediaDevices","getUserMedia","then","catch","handleDataAvailable","event","push","size","localStorage","getItem","removeItem","setItem","click","AbstractModule","showAlert","pop","handleStop","Promise","all","component","attachrecording","blob","Blob","type","mimeType","srcObject","src","URL","createObjectURL","muted","controls","parentElement","classList","remove","textContent","disabled","addEventListener","uploadHandler","uploadfailed","uploadfailed404","uploadaborted","length","uploadToServer","progress","fileURLOrError","insertAnnotation","startRecording","stoprecording","options","selectRecOptions","MediaRecorder","ondataavailable","onstop","start","audiotimelimit","videotimelimit","defaulttimelimit","timerText","innerHTML","setTime","setInterval","types","audioBitsPerSecond","parseInt","audiobitrate","videoBitsPerSecond","videobitrate","compatTypes","filter","isTypeSupported","callback","xhr","XMLHttpRequest","open","responseType","status","response","fileName","Math","random","toString","replace","formData","FormData","filepickerOptions","filepickeroptions","link","repositoryKeys","Object","keys","repositories","append","itemid","i","id","env","M","cfg","sesskey","client_id","context","uploadEndpoint","wwwroot","makeXmlhttprequest","responseText","JSON","parse","url","send","uploadprogress","window","onreadystatechange","readyState","upload","e","round","loaded","total","error","stop","tracks","getTracks","pad","val","valString","document","querySelector","createAnnotation","recordingurl","html","annotation","editor","insertContent","currentModal","destroy"],"mappings":"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"}