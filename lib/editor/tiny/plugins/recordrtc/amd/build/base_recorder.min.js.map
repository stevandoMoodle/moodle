{"version":3,"file":"base_recorder.min.js","sources":["../src/base_recorder.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n//\n\n/**\n * Tiny Record RTC type.\n *\n * @module      tiny_recordrtc/recording/base\n * @copyright   2022 Stevani Andolo <stevani@hotmail.com.au>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {get_string as getString, get_strings as getStrings} from 'core/str';\nimport {component} from './common';\nimport Pending from 'core/pending';\nimport {getData} from './options';\nimport uploadFile from 'editor_tiny/uploader';\nimport {add as addToast} from 'core/toast';\nimport * as ModalEvents from 'core/modal_events';\nimport * as ModalFactory from 'core/modal_factory';\nimport * as Templates from 'core/templates';\nimport {saveCancelPromise} from 'core/notification';\n\n/**\n * The RecordRTC base class for audio, video, and any other future types\n */\nexport default class {\n\n    /**\n     * Constructor for the RecordRTC class\n     *\n     * @param {TinyMCE} editor The Editor to which the content will be inserted\n     * @param {Modal} modal The Moodle Modal that contains the interface used for recording\n     */\n    constructor(editor, modal) {\n        this.ready = false;\n        this.recordagain = false;\n\n        if (!this.checkAndWarnAboutBrowserCompatibility()) {\n            return;\n        }\n\n        this.editor = editor;\n        this.config = getData(editor).params;\n        this.modal = modal;\n        this.modalRoot = modal.getRoot()[0];\n        this.startStopButton = this.modalRoot.querySelector('button[data-action=\"startstop\"]');\n        this.uploadButton = this.modalRoot.querySelector('button[data-action=\"upload\"]');\n\n\n        this.player = this.configurePlayer();\n        this.registerEventListeners();\n        this.ready = true;\n\n        this.captureUserMedia();\n    }\n\n    /**\n     * Check whether the browser is compatible.\n     *\n     * @returns {boolean}\n     */\n    isReady() {\n        return this.ready;\n    }\n\n    // Disable eslint's valid-jsdoc rule as the following methods are abstract and mnust be overridden by the child class.\n\n    /* eslint-disable valid-jsdoc, no-unused-vars */\n\n    /**\n     * Get the Player element for this type.\n     *\n     * @returns {HTMLElement} The player element, typically an audio or video tag.\n     */\n    configurePlayer() {\n        throw new Error(`configurePlayer() must be implemented in ${this.constructor.name}`);\n    }\n\n    /**\n     * Get the list of supported mimetypes for this recorder.\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/isTypeSupported}\n     *\n     * @returns {string[]} The list of supported mimetypes.\n     */\n    getSupportedTypes() {\n        throw new Error(`getSupportedTypes() must be implemented in ${this.constructor.name}`);\n    }\n\n    /**\n     * Get any recording options passed into the MediaRecorder.\n     * Please note that the mimeType will be fetched from {@link getSupportedTypes()}.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/MediaRecorder#options}\n     * @returns {Object}\n     */\n    getRecordingOptions() {\n        throw new Error(`getRecordingOptions() must be implemented in ${this.constructor.name}`);\n    }\n\n    /**\n     * Get a filename for the generated file.\n     *\n     * Typically this function will take a prefix and add a type-specific suffix such as the extension to it.\n     *\n     * @param {string} prefix The prefix for the filename generated by the recorder.\n     * @returns {string}\n     */\n    getFileName(prefix) {\n        throw new Error(`getFileName() must be implemented in ${this.constructor.name}`);\n    }\n\n    /**\n     * Get a list of constraints as required by the getUserMedia() function.\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#constraints}\n     *\n     * @returns {Object}\n     */\n    getMediaConstraints() {\n        throw new Error(`getMediaConstraints() must be implemented in ${this.constructor.name}`);\n    }\n\n    /**\n     * Whether to start playing the recording as it is captured.\n     * @returns {boolean} Whether to start playing the recording as it is captured.\n     */\n    playOnCapture() {\n        return false;\n    }\n\n    /**\n     * Get the time limit for this recording type.\n     *\n     * @returns {number} The time limit in seconds.\n     */\n    getTimeLimit() {\n        throw new Error(`getTimeLimit() must be implemented in ${this.constructor.name}`);\n    }\n\n    /**\n     * Get the name of the template used when embedding the URL in the editor content.\n     *\n     * @returns {string}\n     */\n    getEmbedTemplateName() {\n        throw new Error(`getEmbedTemplateName() must be implemented in ${this.constructor.name}`);\n    }\n\n    /**\n     * Fetch the Class of the Modal to be displayed.\n     *\n     * @returns {Modal}\n     */\n    static getModalClass() {\n        throw new Error(`getModalClass() must be implemented in ${this.constructor.name}`);\n    }\n\n    /* eslint-enable valid-jsdoc, no-unused-vars */\n\n    /**\n     * Get the options for the MediaRecorder.\n     *\n     * @returns {object} The options for the MediaRecorder instance.\n     */\n    getParsedRecordingOptions() {\n        const types = this.getSupportedTypes();\n        const options = this.getParsedRecordingOptions();\n        const compatTypes = types.filter((type) => window.MediaRecorder.isTypeSupported(type));\n\n        if (compatTypes.length !== 0) {\n            options.mimeType = compatTypes[0];\n        }\n\n        return options;\n    }\n\n    /**\n     * Start capturing the User Media and handle success or failure of the capture.\n     */\n    async captureUserMedia() {\n        this.getButtonContainer('start-stop')?.classList.toggle('hide', true);\n        try {\n            const stream = await navigator.mediaDevices.getUserMedia(this.getMediaConstraints());\n            this.handleCaptureSuccess(stream);\n            this.getButtonContainer('start-stop')?.classList.toggle('hide', false);\n        } catch (error) {\n            this.handleCaptureFailure(error);\n        }\n    }\n\n    /**\n     * Display an error message to the user.\n     *\n     * @param {Promise<string>} title The error title\n     * @param {Promise<string>} content The error message\n     * @returns {Promise<Modal>}\n     */\n    async displayAlert(title, content) {\n        const pendingPromise = new Pending('core/confirm:alert');\n        const ModalFactory = await import('core/modal_factory');\n        const modal = await ModalFactory.create({\n            type: ModalFactory.types.ALERT,\n            title: title,\n            body: content,\n            removeOnClose: true,\n        });\n\n        modal.show();\n        pendingPromise.resolve();\n\n        return modal;\n    }\n\n    /**\n     * Handle successful capture of the User Media.\n     *\n     * @param {MediaStream} stream The stream as captured by the User Media.\n     */\n    handleCaptureSuccess(stream) {\n        // Set audio player source to microphone stream.\n        this.player.srcObject = stream;\n\n        if (this.playOnCapture()) {\n            // Mute audio, distracting while recording.\n            this.player.muted = true;\n\n            this.player.play();\n        }\n\n        this.stream = stream;\n        this.setupPlayerSource();\n    }\n\n    setupPlayerSource() {\n        if (!this.player.srcObject) {\n            this.player.srcObject = this.stream;\n\n            // Mute audio, distracting while recording.\n            this.player.muted = true;\n\n            this.player.play();\n        }\n    }\n\n    /**\n     * Handle failure to capture the User Media.\n     *\n     * @param {Error} error\n     */\n    handleCaptureFailure(error) {\n        // Changes 'CertainError' -> 'gumcertain' to match language string names.\n        var subject = `gum${error.name.replace('Error', '').toLowerCase()}`;\n        this.displayAlert(\n            getString(`${subject}_title`, component),\n            getString(subject, component)\n        );\n    }\n\n    /**\n     * Close the modal and stop recording.\n     */\n    close() {\n        // Closing the modal will destroy it and remove it from the DOM.\n        // It will also stop the recording via the hidden Modal Event.\n        this.modal.hide();\n    }\n\n    /**\n     * Register event listeners for the modal.\n     */\n    registerEventListeners() {\n        this.modalRoot.addEventListener('click', this.handleModalClick.bind(this));\n        this.modal.getRoot().on(ModalEvents.outsideClick, this.outsideClickHandler.bind(this));\n        this.modal.getRoot().on(ModalEvents.hidden, () => {\n            this.cleanupStream();\n            this.stopRecording();\n        });\n    }\n\n    /**\n     * Prevent the Modal from closing when recording is on process.\n     *\n     * @param {MouseEvent} event The click event\n     */\n    async outsideClickHandler(event) {\n        if (this.isRecording()) {\n            // The user is recording.\n            // Do not distract with a confirmation, just prevent closing.\n            event.preventDefault();\n        } else if (this.data?.blobSize) {\n            // If there is a blobsize then there is data that may be lost.\n            // Ask the user to confirm they want to close the modal.\n            // We prevent default here, and then close the modal if they confirm.\n            event.preventDefault();\n\n            try {\n                await saveCancelPromise(\n                    await getString(\"discard_title\", component),\n                    await getString(\"discard_desc\", component),\n                    await getString(\"confirm_yes\", component),\n                );\n                this.modal.hide();\n            } catch (error) {\n                // Do nothing, the modal will not close.\n            }\n        }\n    }\n\n    /**\n     * Handle a click within the Modal.\n     *\n     * @param {MouseEvent} event The click event\n     */\n    handleModalClick(event) {\n        const button = event.target.closest('button');\n        if (button && button.dataset.action) {\n            const action = button.dataset.action;\n            if (action === 'startstop') {\n                this.handleRecordingStartStopRequested();\n            }\n\n            if (action === 'upload') {\n                this.uploadRecording();\n            }\n        }\n    }\n\n    /**\n     * Handle the click event for the recording start/stop button.\n     */\n    handleRecordingStartStopRequested() {\n        if (this.mediaRecorder?.state === 'recording') {\n            this.stopRecording();\n        } else {\n            this.startRecording();\n        }\n    }\n\n    /**\n     * Handle the media stream after it has finished.\n     */\n    async onMediaStopped() {\n        // Set source of audio player.\n        this.blob = new Blob(this.data.chunks, {\n            type: this.mediaRecorder.mimeType\n        });\n        this.player.srcObject = null;\n        this.player.src = URL.createObjectURL(this.blob);\n\n        // Change the label to \"Record again\".\n        getString(\"recordagain\", component).then(res => {\n            this.startStopButton.textContent = res;\n            return;\n        }).catch();\n\n        // Show audio player with controls enabled, and unmute.\n        this.player.muted = false;\n        this.player.controls = true;\n        this.getButtonContainer('player')?.classList.toggle('hide', false);\n\n        // Show upload button.\n        const uploadContainer = this.getButtonContainer('upload');\n        uploadContainer.classList.toggle('hide', false);\n        this.uploadButton.disabled = false;\n    }\n\n    /**\n     * Upload the recording and insert it into the editor content.\n     */\n    async uploadRecording() {\n        // Trigger error if no recording has been made.\n        if (this.data.chunks.length === 0) {\n            this.displayAlert('norecordingfound');\n            return;\n        }\n\n        const uploadContainer = this.getButtonContainer('upload');\n        uploadContainer.classList.toggle('hide', true);\n\n        const fileName = this.getFileName((Math.random() * 1000).toString().replace('.', ''));\n\n        // Upload recording to server.\n        try {\n            const fileURL = await uploadFile(this.editor, 'media', this.blob, fileName, (progress) => {\n                // TODO Display the progress somewhere.\n                window.console.log(progress);\n            });\n            this.insertMedia(fileURL);\n            this.close();\n            addToast(await getString('recordinguploaded', component));\n        } catch (error) {\n            // Show a toast and unhide the button.\n            addToast(await getString('uploaderror', component), {\n                type: 'error',\n            });\n            uploadContainer.classList.toggle('hide', false);\n        }\n    }\n\n    /**\n     * Helper to get the container that a button is in.\n     *\n     * @param {string} purpose The button purpose\n     * @returns {HTMLElement}\n     */\n    getButtonContainer(purpose) {\n        return this.modalRoot.querySelector(`[data-purpose=\"${purpose}-container\"]`);\n    }\n\n    /**\n     * Check whether the browser is compatible with capturing media.\n     *\n     * @returns {boolean}\n     */\n    static isBrowserCompatible() {\n        return this.checkSecure() && this.hasUserMedia();\n    }\n\n    static async display(editor) {\n        const ModalClass = this.getModalClass();\n        const modal = await ModalFactory.create({\n            type: ModalClass.TYPE,\n            templateContext: {},\n            large: true,\n        });\n\n        // Set up the VideoRecorder.\n        const recorder = new this(editor, modal);\n        if (recorder.isReady()) {\n            modal.show();\n        }\n        return modal;\n    }\n\n    /**\n     * Check whether the browser is compatible with capturing media, and display a warning if not.\n     *\n     * @returns {boolean}\n     */\n    checkAndWarnAboutBrowserCompatibility() {\n        if (!this.constructor.checkSecure()) {\n            getStrings(['insecurealert_title', 'insecurealert'].map((key) => ({key, component})))\n                .then(([title, message]) => addToast(message, {title, type: 'error'}))\n                .catch();\n            return false;\n        }\n\n        if (!this.constructor.hasUserMedia) {\n            getStrings(['nowebrtc_title', 'nowebrtc'].map((key) => ({key, component})))\n                .then(([title, message]) => addToast(message, {title, type: 'error'}))\n                .catch();\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Check whether the browser supports WebRTC.\n     *\n     * @returns {boolean}\n     */\n    static hasUserMedia() {\n        return (navigator.mediaDevices && window.MediaRecorder);\n    }\n\n    /**\n     *  Notify and redirect user if plugin is used from insecure location.\n     *\n     * @returns {boolean} Whether the plugin can be loaded.\n     */\n    static checkSecure() {\n        return (window.location.protocol === 'https:') || (window.location.host.indexOf('localhost') !== -1);\n    }\n\n    /**\n     * Update the content of the stop recording button timer.\n     */\n    async setStopRecordingButton() {\n        const {html, js} = await Templates.renderForPromise('tiny_recordrtc/timeremaining', this.getTimeRemaining());\n        Templates.replaceNodeContents(this.startStopButton, html, js);\n        this.buttonTimer = setInterval(this.updateButtonTime.bind(this), 500);\n    }\n\n    /**\n     * Update the time on the stop recording button.\n     */\n    updateButtonTime() {\n        const {remaining, minutes, seconds} = this.getTimeRemaining();\n        if (remaining < 0) {\n            this.stopRecording();\n        } else {\n            this.startStopButton.querySelector('[data-type=\"minutes\"]').textContent = minutes;\n            this.startStopButton.querySelector('[data-type=\"seconds\"]').textContent = seconds;\n        }\n    }\n\n    /**\n     * Clear the timer for the stop recording button.\n     */\n    clearButtonTimer() {\n        if (this.buttonTimer) {\n            clearInterval(this.buttonTimer);\n        }\n        this.buttonTimer = null;\n    }\n\n    /**\n     * Get the time remaining for the recording.\n     *\n     * @returns {Object} The minutes and seconds remaining.\n     */\n    getTimeRemaining() {\n        // All times are in milliseconds\n        const now = new Date().getTime();\n        const remaining = Math.floor(this.getTimeLimit() - ((now - this.startTime) / 1000));\n\n        const formatter = new Intl.NumberFormat(navigator.language, {minimumIntegerDigits: 2});\n        const seconds = formatter.format(remaining % 60);\n        const minutes = formatter.format(Math.floor((remaining - seconds) / 60));\n        return {\n            remaining,\n            minutes,\n            seconds,\n        };\n    }\n\n    /**\n     * Get the maximum file size that can be uploaded.\n     *\n     * @returns {number} The max byte size\n     */\n    getMaxUploadSize() {\n        return this.config.maxrecsize;\n    }\n\n    /**\n     * Stop the recording.\n     * Please note that this should only stop the recording.\n     * Anything related to processing the recording should be handled by the\n     * mediaRecorder's stopped event handler which is processed after it has stopped.\n     */\n    stopRecording() {\n        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {\n            this.mediaRecorder.stop();\n\n            // Unmute the player so that the audio is heard during playback.\n            this.player.muted = false;\n        } else {\n            // There is no recording to stop, but the stream must still be cleaned up.\n            this.cleanupStream();\n        }\n    }\n\n    /**\n     * Clean up the stream.\n     *\n     * This involves stopping any track which is still active.\n     */\n    cleanupStream() {\n        if (this.stream) {\n            this.stream.getTracks()\n                .filter((track) => track.readyState !== 'ended')\n                .forEach((track) => track.stop());\n        }\n    }\n\n    /**\n     * Handle the mediaRecorder `stop` event.\n     */\n    handleStopped() {\n        // Handle the stream data.\n        this.onMediaStopped();\n\n        // Clear the button timer.\n        this.clearButtonTimer();\n    }\n\n    /**\n     * Handle the mediaRecorder `start` event.\n     *\n     * This event is called when the recording starts.\n     */\n    handleStarted() {\n        this.startTime = new Date().getTime();\n        this.setStopRecordingButton();\n    }\n\n    /**\n     * Handle the mediaRecorder `dataavailable` event.\n     *\n     * @param {Event} event\n     */\n    handleDataAvailable(event) {\n        if (this.isRecording()) {\n            const newSize = this.data.blobSize + event.data.size;\n            // Recording stops when either the maximum upload size is reached, or the time limit expires.\n            // The time limit is checked in the `updateButtonTime` function.\n            if (newSize >= this.getMaxUploadSize()) {\n                this.stopRecording();\n                this.displayFileLimitHitMessage();\n            } else {\n                // Push recording slice to array.\n                this.data.chunks.push(event.data);\n\n                // Size of all recorded data so far.\n                this.data.blobSize = newSize;\n            }\n        }\n    }\n\n    async displayFileLimitHitMessage() {\n        addToast(await getString('maxfilesizehit', component), {\n            title: await getString('maxfilesizehit_title', component),\n            type: 'error',\n        });\n    }\n\n    /**\n     * Check whether the recording is in progress.\n     *\n     * @returns {boolean}\n     */\n    isRecording() {\n        return this.mediaRecorder?.state === 'recording';\n    }\n\n    /**\n     * Start the recording\n     */\n    async startRecording() {\n        if (this.mediaRecorder) {\n            // Stop the existing recorder if it exists.\n            if (this.isRecording()) {\n                this.mediaRecorder.stop();\n            }\n\n            if (!this.recordagain) {\n                this.recordAgainConfirmation();\n            } else {\n                this.mediaRecorder = null;\n            }\n        } else {\n            this.recordagain = true;\n        }\n\n        if (this.recordagain) {\n            // The options for the recording codecs and bitrates.\n            this.mediaRecorder = new MediaRecorder(this.stream, this.getParsedRecordingOptions());\n\n            this.mediaRecorder.addEventListener('dataavailable', this.handleDataAvailable.bind(this));\n            this.mediaRecorder.addEventListener('stop', this.handleStopped.bind(this));\n            this.mediaRecorder.addEventListener('start', this.handleStarted.bind(this));\n\n            this.data = {\n                chunks: [],\n                blobSize: 0\n            };\n            this.setupPlayerSource();\n\n            this.mediaRecorder.start(1000); // Capture in 1s chunks. Must be set to work with Firefox.\n\n            // Set the state back to false.\n            this.recordagain = false;\n        }\n    }\n\n    async recordAgainConfirmation() {\n        try {\n            await saveCancelPromise(\n                await getString(\"recordagain_title\", component),\n                await getString(\"recordagain_desc\", component),\n                await getString(\"confirm_yes\", component)\n            );\n            this.recordagain = true;\n            this.getButtonContainer('upload')?.classList.toggle('hide', true);\n            this.startRecording();\n            this.modal.close();\n        } catch {\n            // Do nothing.\n        }\n    }\n\n    /**\n     * Insert the HTML to embed the recording into the editor content.\n     *\n     * @param {string} source The URL to view the media.\n     */\n    async insertMedia(source) {\n        const {html} = await Templates.renderForPromise(\n            this.getEmbedTemplateName(),\n            this.getEmbedTemplateContext({\n                source,\n            })\n        );\n        this.editor.insertContent(html);\n    }\n\n    /**\n     * Add or modify the template parameters for the specified type.\n     *\n     * @param {Object} templateContext The Tempalte context to use\n     * @returns {Object} The finalised template context\n     */\n    getEmbedTemplateContext(templateContext) {\n        return templateContext;\n    }\n}\n"],"names":["editor","modal","ready","recordagain","this","checkAndWarnAboutBrowserCompatibility","config","params","modalRoot","getRoot","startStopButton","querySelector","uploadButton","player","configurePlayer","registerEventListeners","captureUserMedia","Error","constructor","name","prefix","types","getSupportedTypes","options","getParsedRecordingOptions","compatTypes","filter","type","window","MediaRecorder","isTypeSupported","length","mimeType","getButtonContainer","classList","toggle","navigator","mediaDevices","getUserMedia","getMediaConstraints","stream","handleCaptureSuccess","handleCaptureFailure","title","content","pendingPromise","Pending","ModalFactory","create","ALERT","body","removeOnClose","show","resolve","srcObject","playOnCapture","muted","play","setupPlayerSource","error","subject","replace","toLowerCase","displayAlert","component","hide","addEventListener","handleModalClick","bind","on","ModalEvents","outsideClick","outsideClickHandler","hidden","_this","cleanupStream","stopRecording","event","isRecording","preventDefault","data","_this$data","blobSize","saveCancelPromise","button","target","closest","dataset","action","handleRecordingStartStopRequested","uploadRecording","mediaRecorder","state","startRecording","blob","Blob","chunks","src","URL","createObjectURL","then","res","_this2","textContent","catch","controls","disabled","uploadContainer","fileName","getFileName","Math","random","toString","progress","console","log","fileURL","insertMedia","close","addToast","purpose","checkSecure","hasUserMedia","map","key","message","Templates","renderForPromise","getTimeRemaining","html","js","replaceNodeContents","buttonTimer","setInterval","updateButtonTime","remaining","minutes","seconds","clearInterval","now","Date","getTime","floor","getTimeLimit","startTime","formatter","Intl","NumberFormat","language","minimumIntegerDigits","format","maxrecsize","stop","getTracks","track","readyState","forEach","onMediaStopped","clearButtonTimer","setStopRecordingButton","newSize","size","getMaxUploadSize","displayFileLimitHitMessage","push","recordAgainConfirmation","handleDataAvailable","handleStopped","handleStarted","start","source","getEmbedTemplateName","getEmbedTemplateContext","insertContent","templateContext","ModalClass","getModalClass","TYPE","large","isReady","location","protocol","host","indexOf"],"mappings":"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"}