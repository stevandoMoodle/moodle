{"version":3,"file":"embedinsert.min.js","sources":["../../src/embed/embedinsert.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny media plugin embed upload class.\n *\n * This handles the embed upload using url, drag-drop and repositories.\n *\n * @module      tiny_media/embed/embedinsert\n * @copyright   2024 Stevani Andolo <stevani@hotmail.com.au>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {prefetchStrings} from 'core/prefetch';\nimport {getStrings, getString} from 'core/str';\nimport {component} from \"../common\";\nimport {\n    setPropertiesFromData,\n    startMediaLoading,\n    stopMediaLoading,\n    showElements,\n} from '../helpers';\nimport Selectors from \"../selectors\";\nimport Dropzone from 'core/dropzone';\nimport uploadFile from 'editor_tiny/uploader';\nimport {EmbedHandler} from './embedhandler';\nimport {\n    formatMediaUrl,\n    mediaDetailsTemplateContext,\n    getFileMimeTypeFromUrl,\n} from './embedhelpers';\nimport {EmbedPreview} from './embedpreview';\nimport EmbedModal from '../embedmodal';\nimport Templates from 'core/templates';\n\nprefetchStrings(component, [\n    'insertmedia',\n    'addmediafilesdrop',\n    'uploading',\n    'loadingmedia',\n]);\n\nexport class EmbedInsert {\n\n    constructor(data) {\n        setPropertiesFromData(this, data); // Creates dynamic properties based on \"data\" param.\n    }\n\n    /**\n     * Init the dropzone and lang strings.\n     */\n    init = async() => {\n        const langStringKeys = [\n            'insertmedia',\n            'addmediafilesdrop',\n            'uploading',\n            'loadingmedia',\n        ];\n        const langStringValues = await getStrings([...langStringKeys].map((key) => ({key, component})));\n        this.langStrings = Object.fromEntries(langStringKeys.map((key, index) => [key, langStringValues[index]]));\n        this.currentModal.setTitle(this.langStrings.insertmedia);\n\n        // Let's init the dropzone if canShowDropZone is true and mediaType is null.\n        if (this.canShowDropZone && !this.mediaType) {\n            const dropZoneEle = document.querySelector(Selectors.EMBED.elements.dropzoneContainer);\n            const dropZone = new Dropzone(\n                dropZoneEle,\n                'audio/*,video/*',\n                files => {\n                    this.handleUploadedFile(files);\n                }\n            );\n\n            dropZone.setLabel(this.langStrings.addmediafilesdrop);\n            dropZone.init();\n        }\n    };\n\n    /**\n     * Loads and displays a preview media based on the provided URL, and handles media loading events.\n     *\n     * @param {string} url - The URL of the media to load and display.\n     */\n    loadMediaPreview = async(url) => {\n        this.originalUrl = url;\n        const [formattedUrl, type, title] = await formatMediaUrl(url, this);\n\n        this.mediaSource = formattedUrl;\n        if (title) {\n            this.fetchedMediaLinkTitle = title;\n        }\n\n        // Get media mime type.\n        const mediaType = type ?? await getFileMimeTypeFromUrl(this.mediaSource);\n\n        // Check if mediaType is not \"link\" and is acceptable.\n        if (!Selectors.EMBED.mediaTypes.includes(mediaType)) {\n            // Display warning message if the mediaType is not acceptable.\n            const urlWarningLabelEle = this.root.querySelector(Selectors.EMBED.elements.urlWarning);\n            urlWarningLabelEle.innerHTML = await getString('onlymediafilesdesc', component);\n            showElements(Selectors.EMBED.elements.urlWarning, this.root);\n\n            // Stop the spinner.\n            stopMediaLoading(this.root, Selectors.EMBED.type);\n            return; // End it here if the mimetype is not acceptable.\n        }\n\n        // Else, continue checking if new upload and mediaType is \"link\" or\n        // a new inserted link and the new mediaType is \"link\".\n        if ((!this.isUpdating || this.newMediaLink) && mediaType === 'link') {\n            // Create media type selector modal prop.\n            this.mediaTypeSelectorModal = await EmbedModal.create({\n                large: false,\n                title: getString('medialinktypeselector', component),\n                templateContext: {elementid: this.editor.getElement().id},\n                body: await Templates.render(`${component}/embed/link_media_type_selector`),\n            });\n\n            // Create media type selector root prop.\n            this.mediaTypeSelectorRoot = this.mediaTypeSelectorModal.getRoot()[0];\n\n            // Register the media type selector root events.\n            this.registerMediaTypeSelectorEvents(this.mediaTypeSelectorRoot);\n\n            // Stop the spinner.\n            stopMediaLoading(this.root, Selectors.EMBED.type);\n        } else {\n            // Process the media preview.\n            this.processMediaPreview(mediaType);\n        }\n    };\n\n    /**\n     * Process the media preview.\n     * @param {string} mediaType\n     */\n    processMediaPreview = async(mediaType) => {\n        // Set mediaType to newly fetched mime type.\n        this.mediaType = (this.mediaType && mediaType !== 'link') ? this.mediaType : mediaType;\n\n        // Let's combine the props.\n        setPropertiesFromData(\n            this,\n            await (new EmbedHandler(this)).getMediaTemplateContext()\n        );\n\n        // Construct templateContext for embed preview.\n        const templateContext = await mediaDetailsTemplateContext(this);\n\n        if (this.mediaType === 'video' && this.isUpdating) {\n            // Let's get selected video height & width and create props for them to be used in embedPreview.\n            const media = templateContext.media;\n            if (media.height !== '' && media.width !== '') {\n                this.mediaHeight = media.height;\n                this.mediaWidth = media.width;\n            }\n        }\n\n        if (this.isUpdating && !this.newMediaLink) {\n            // Will be used to set the media title if it's in update state.\n            this.mediaTitle = templateContext.media.title;\n        }\n\n        // Load the media details and preview of the selected media.\n        (new EmbedHandler(this)).loadMediaDetails(new EmbedPreview(this), templateContext);\n    };\n\n    /**\n     * Updates the content of the loader icon.\n     *\n     * @param {HTMLElement} root - The root element containing the loader icon.\n     * @param {object} langStrings - An object containing language strings.\n     * @param {number|null} progress - The progress percentage (optional).\n     * @returns {void}\n     */\n    updateLoaderIcon = (root, langStrings, progress = null) => {\n        const loaderIconState = root.querySelector(Selectors.EMBED.elements.loaderIconContainer + ' div');\n        loaderIconState.innerHTML = (progress !== null) ?\n                               `${langStrings.uploading} ${Math.round(progress)}%` :\n                               langStrings.loadingmedia;\n    };\n\n    /**\n     * Handles media preview on file picker callback.\n     *\n     * @param {object} params Object of uploaded file\n     */\n    filePickerCallback = (params) => {\n        if (params.url) {\n            if (this.mediaTagType) {\n                // Delete mediaTagType if it started with viewing embedded link,\n                // otherwise it will break the media preview check.\n                delete this.mediaTagType;\n\n                // Set mediaType to \"null\" if it started with viewing embedded link,\n                // otherwise it will not be consistent when checking in ::processMediaPreview().\n                this.mediaType = null;\n            }\n\n            // Flag as new file upload.\n            this.newFileUpload = true;\n\n            // Load the media preview.\n            this.loadMediaPreview(params.url);\n        }\n    };\n\n    /**\n     * Handles the uploaded file, initiates the upload process, and updates the UI during the upload.\n     *\n     * @param {FileList} files - The list of files to upload (usually from a file input field).\n     * @returns {Promise<void>} A promise that resolves when the file is uploaded and processed.\n     */\n    handleUploadedFile = async(files) => {\n        try {\n            startMediaLoading(this.root, Selectors.EMBED.type);\n            const fileURL = await uploadFile(this.editor, 'media', files[0], files[0].name, (progress) => {\n                this.updateLoaderIcon(this.root, this.langStrings, progress);\n            });\n\n            // Set the loader icon content to \"loading\" after the file upload completes.\n            this.updateLoaderIcon(this.root, this.langStrings);\n            this.filePickerCallback({url: fileURL});\n        } catch (error) {\n            // Handle the error.\n            const urlWarningLabelEle = this.root.querySelector(Selectors.EMBED.elements.urlWarning);\n            urlWarningLabelEle.innerHTML = error.error !== undefined ? error.error : error;\n            showElements(Selectors.EMBED.elements.urlWarning, this.root);\n            stopMediaLoading(this.root, Selectors.EMBED.type);\n        }\n    };\n\n    registerMediaTypeSelectorEvents = (root) => {\n        const mediaLinkAsAudio = root.querySelector(Selectors.EMBED.actions.mediaLinkAsAudio);\n        if (mediaLinkAsAudio) {\n            mediaLinkAsAudio.addEventListener('click', () => {\n                this.mediaTagType = 'audio';\n                this.mediaTypeSelectorModal.destroy();\n                startMediaLoading(this.root, Selectors.EMBED.type);\n                this.processMediaPreview('link'); // Let's preview as \"link\".\n            });\n        }\n\n        const mediaLinkAsVideo = root.querySelector(Selectors.EMBED.actions.mediaLinkAsVideo);\n        if (mediaLinkAsVideo) {\n            mediaLinkAsVideo.addEventListener('click', () => {\n                this.mediaTagType = 'video';\n                this.mediaTypeSelectorModal.destroy();\n                startMediaLoading(this.root, Selectors.EMBED.type);\n                this.processMediaPreview('link'); // Let's preview as \"link\".\n            });\n        }\n    };\n}\n"],"names":["component","constructor","data","async","langStringKeys","langStringValues","map","key","langStrings","Object","fromEntries","index","currentModal","setTitle","this","insertmedia","canShowDropZone","mediaType","dropZoneEle","document","querySelector","Selectors","EMBED","elements","dropzoneContainer","dropZone","Dropzone","files","handleUploadedFile","setLabel","addmediafilesdrop","init","originalUrl","url","formattedUrl","type","title","mediaSource","fetchedMediaLinkTitle","mediaTypes","includes","root","urlWarning","innerHTML","isUpdating","newMediaLink","processMediaPreview","mediaTypeSelectorModal","EmbedModal","create","large","templateContext","elementid","editor","getElement","id","body","Templates","render","mediaTypeSelectorRoot","getRoot","registerMediaTypeSelectorEvents","EmbedHandler","getMediaTemplateContext","media","height","width","mediaHeight","mediaWidth","mediaTitle","loadMediaDetails","EmbedPreview","progress","loaderIconState","loaderIconContainer","uploading","Math","round","loadingmedia","params","mediaTagType","newFileUpload","loadMediaPreview","fileURL","name","updateLoaderIcon","filePickerCallback","error","undefined","mediaLinkAsAudio","actions","addEventListener","destroy","mediaLinkAsVideo"],"mappings":"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"}