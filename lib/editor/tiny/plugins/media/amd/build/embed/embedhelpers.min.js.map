{"version":3,"file":"embedhelpers.min.js","sources":["../../src/embed/embedhelpers.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny media plugin embed helpers.\n *\n * This provides easy access to any classes without instantiating a new object.\n *\n * @module      tiny_media/embed/embedhelpers\n * @copyright   2024 Stevani Andolo <stevani@hotmail.com.au>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Selectors from '../selectors';\nimport {getStrings, getString} from 'core/str';\nimport {component} from \"../common\";\nimport {\n    getCurrentLanguage,\n    getMoodleLang\n} from 'editor_tiny/options';\nimport {createUrlParams} from '../helpers';\n\n/**\n * Return template context for insert media.\n *\n * @param {object} props\n * @returns {object}\n */\nexport const insertMediaTemplateContext = (props) => {\n    return {\n        mediaType: props.mediaType,\n        showDropzone: props.canShowDropZone,\n        showFilePicker: props.canShowFilePicker,\n        fileType: 'audio/video',\n    };\n};\n\n/**\n * Return template context for insert media.\n *\n * @param {object} props\n * @returns {object}\n */\nexport const insertMediaThumbnailTemplateContext = (props) => {\n    return {\n        elementid: props.editor.id,\n        showDropzone: props.canShowDropZone,\n        bodyTemplate: Selectors.EMBED.template.body.insertMediaBody,\n        footerTemplate: Selectors.EMBED.template.footer.insertMediaFooter,\n        fileType: 'image',\n        selector: Selectors.EMBED.type,\n    };\n};\n\n/**\n * Return selected media type and element.\n *\n * @param {editor} editor\n * @returns {Array}\n */\nexport const getSelectedMediaElement = (editor) => {\n    let mediaType = null;\n    let selectedMedia = null;\n    const mediaElm = editor.selection.getNode();\n\n    if (!mediaElm) {\n        mediaType = null;\n        selectedMedia = null;\n    } else if (mediaElm.nodeName.toLowerCase() === 'video' || mediaElm.nodeName.toLowerCase() === 'audio') {\n        mediaType = mediaElm.nodeName.toLowerCase();\n        selectedMedia = mediaElm;\n    } else if (mediaElm.querySelector('video')) {\n        mediaType = 'video';\n        selectedMedia = mediaElm.querySelector('video');\n    } else if (mediaElm.querySelector('audio')) {\n        mediaType = 'audio';\n        selectedMedia = mediaElm.querySelector('audio');\n    }\n\n    return [mediaType, selectedMedia];\n};\n\n/**\n * This is used to format the media url (without file extension),\n * so it can be previewed from the following providers:\n * 1. YouTube.\n * 2. Vimeo.\n *\n * If the links are based on the checks the type will be \"link\",\n * otherwise it will be \"null\" and the url will be later checked in ::getFileMimeTypeFromUrl().\n *\n * @param {string} url\n * @param {object} props\n * @returns {Array} Array of formatted url and type.\n */\nexport const formatMediaUrl = async(url, props) => {\n    let params = {};\n    let media = null;\n\n    // Check if selectedMedia prop has value.\n    if (props.selectedMedia) {\n        media = props.selectedMedia;\n\n        // Create object of params.\n        params = {\n            controls: hasAudioVideoAttr(media, 'controls') ? '1' : '0',\n            autoplay: hasAudioVideoAttr(media, 'autoplay') ? '1' : '0',\n            loop: hasAudioVideoAttr(media, 'loop'),\n        };\n    }\n\n    let urlParams = '';\n    const [isYoutube, youtubeType] = isYoutubeUrl(url);\n    if (isYoutube) {\n        let fetchUrl = await fetch(`https://www.youtube.com/oembed?url=${url}&format=json`);\n        let youtubeData = JSON.parse(await fetchUrl.text());\n\n        // YouTube regex.\n        const youtubeRegex = /(youtu.*be.*|y2u.*be.*)\\/(watch\\?v=|embed\\/|v|shorts|)(.*?((?=[&#?])|$))/gm.exec(url);\n        // Get youtube site.\n        const site = youtubeRegex[1];\n        // It will equal to video id or \"playlist\" type.\n        const idOrType = youtubeRegex[3];\n        // Playlist check regex.\n        const playlistCheckRegex = /[?&]list=([^#?&]*)/;\n\n        // Only applies if selectedMedia prop has value.\n        if (props.selectedMedia) {\n            // YouTube mute param is \"mute\".\n            params.mute = hasAudioVideoAttr(media, 'muted');\n        }\n\n        // Check if it's YouTube playlist.\n        let isYoutubePlaylist = false;\n        if (idOrType === 'playlist' || playlistCheckRegex.test(url)) {\n            isYoutubePlaylist = true;\n        }\n\n        const isShort = ['youtu.be', 'y2u.be'].includes(site);\n        const isNoCookie = (youtubeType === 'youtube-nocookie.com');\n\n        if (isYoutubePlaylist) {\n            params.list = /[&?]list=([^&]+)/i.exec(url)[1];\n            urlParams = createUrlParams(params);\n            urlParams = urlParams === '' ? '' : `?${urlParams}`;\n\n            if (isNoCookie) {\n                url = `https://www.youtube-nocookie.com/embed/videoseries${urlParams}`;\n            } else {\n                url = `https://${(isShort) ? 'youtube.com' : site}/embed/videoseries${urlParams}`;\n            }\n        } else {\n            urlParams = createUrlParams(params);\n            urlParams = urlParams === '' ? '' : `?${urlParams}`;\n\n            if (isNoCookie) {\n                url = `https://www.youtube-nocookie.com/embed/${idOrType + urlParams}`;\n            } else {\n                url = `https://${(isShort) ? 'youtube.com' : site}/embed/${idOrType + urlParams}`;\n            }\n        }\n\n        return [url, 'link', youtubeData.title];\n    } else if (url.includes('https://vimeo.com/')) {\n        // Only applies if selectedMedia prop has value.\n        if (props.selectedMedia) {\n            // Vimeo mute param is \"muted\".\n            params.muted = hasAudioVideoAttr(media, 'muted');\n        }\n\n        urlParams = createUrlParams(params);\n        urlParams = urlParams === '' ? '' : `?${urlParams}`;\n\n        // Get vimeo video id.\n        const vimeoVideoIdRegExp = /^.*(vimeo\\.com\\/)((channels\\/[A-z]+\\/)|(groups\\/[A-z]+\\/videos\\/))?([0-9]+)/;\n        const vimeoVideoId = url.match(vimeoVideoIdRegExp)[5];\n        // Get vimeo video data.\n        const fetchUrl = await fetch(`https://vimeo.com/api/v2/video/${vimeoVideoId}.json`);\n        const vimeoData = JSON.parse(await fetchUrl.text())[0];\n\n        return [\n            // Vimeo original link: https://vimeo.com/012345?params.\n            url.replaceAll('vimeo.com', 'player.vimeo.com/video') + urlParams,\n            // Vimeo embed link: https://player.vimeo.com/video/012345?params.\n            'link',\n            vimeoData.title,\n        ];\n    }\n\n    // Return original url and \"null\" as the type.\n    return [url, null, null];\n};\n\n/**\n * Check if url is YouTube url.\n *\n * @param {string} url\n * @returns {Array}\n */\nexport const isYoutubeUrl = (url) => {\n    let isYoutube = false;\n    let type = null;\n    const youtubeTypes = [\n        'youtube.com',\n        'youtube-nocookie.com',\n        'youtu.be',\n        'y2u.be'\n    ];\n\n    for (let i = 0; i < youtubeTypes.length; i++) {\n        if (url.includes(youtubeTypes[i])) {\n            isYoutube = true;\n            type = youtubeTypes[i];\n            break;\n        }\n    }\n\n    return [isYoutube, type];\n};\n\n/**\n * Return template context for media details.\n *\n * @param {object} props\n * @returns {object}\n */\nexport const mediaDetailsTemplateContext = async(props) => {\n    const context = {\n        bodyTemplate: Selectors.EMBED.template.body.mediaDetailsBody,\n        footerTemplate: Selectors.EMBED.template.footer.mediaDetailsFooter,\n        isVideo: (props.mediaType === 'video'),\n        isAudio: (props.mediaType === 'audio'),\n        isLink: (props.mediaType === 'link'),\n        canHaveThumbnail: (props.mediaType === 'video' || props.mediaTagType === 'video'),\n        isUpdating: props.isUpdating,\n        isNewFileOrLinkUpload: (props.newMediaLink || props.newFileUpload),\n        selector: Selectors.EMBED.type,\n    };\n\n    // Props for link mediaType to form a select element for audio and video.\n    if (context.isLink) {\n        context.linkMediaType = [\n            {\n                label: await getString('audio', component),\n                value: 'audio',\n                selected: (props.mediaTagType === 'audio') ? 'selected' : '',\n            },\n            {\n                label: await getString('video', component),\n                value: 'video',\n                selected: (props.mediaTagType === 'video') ? 'selected' : '',\n            }\n        ];\n    }\n\n    return {...context, ...props};\n};\n\n/**\n * Get help strings.\n *\n * @returns {object}\n */\nexport const getHelpStrings = async() => {\n    const [\n        customsize,\n        linkcustomsize,\n    ] = await getStrings([\n        'customsize_help',\n        'linkcustomsize_help',\n    ].map((key) => ({\n        key,\n        component,\n    })));\n\n    return {\n        customsize,\n        linkcustomsize,\n    };\n};\n\n/**\n * Get current moodle languages.\n *\n * @param {editor} editor\n * @returns {object}\n */\nexport const prepareMoodleLang = (editor) => {\n    const moodleLangs = getMoodleLang(editor);\n    const currentLanguage = getCurrentLanguage(editor);\n\n    const installed = Object.entries(moodleLangs.installed).map(([lang, code]) => ({\n        lang,\n        code,\n        \"default\": lang === currentLanguage,\n    }));\n\n    const available = Object.entries(moodleLangs.available).map(([lang, code]) => ({\n        lang,\n        code,\n        \"default\": lang === currentLanguage,\n    }));\n\n    return {\n        installed,\n        available,\n    };\n};\n\n/**\n * Return moodle lang.\n *\n * @param {string} subtitleLang\n * @param {editor} editor\n * @returns {object|null}\n */\nexport const getMoodleLangObj = (subtitleLang, editor) => {\n    const {available} = getMoodleLang(editor);\n\n    if (available[subtitleLang]) {\n        return {\n            lang: subtitleLang,\n            code: available[subtitleLang],\n        };\n    }\n\n    return null;\n};\n\n/**\n * Get media data from the inserted media.\n *\n * @param {object} props\n * @returns {object}\n */\nexport const getEmbeddedMediaDetails = (props) => {\n    const tracks = {\n        subtitles: [],\n        captions: [],\n        descriptions: [],\n        chapters: [],\n        metadata: []\n    };\n\n    const mediaMetadata = props.root.querySelectorAll(Selectors.EMBED.elements.mediaMetadataTabPane);\n    mediaMetadata.forEach(metaData => {\n        const trackElements = metaData.querySelectorAll(Selectors.EMBED.elements.track);\n        trackElements.forEach(track => {\n            tracks[metaData.dataset.trackKind].push({\n                src: track.querySelector(Selectors.EMBED.elements.url).value,\n                srclang: track.querySelector(Selectors.EMBED.elements.trackLang).value,\n                label: track.querySelector(Selectors.EMBED.elements.trackLabel).value,\n                defaultTrack: track.querySelector(Selectors.EMBED.elements.trackDefault).checked,\n            });\n        });\n    });\n\n    const querySelector = (element) => props.root.querySelector(element);\n    const mediaDataProps = {};\n    mediaDataProps.media = {\n        type: props.mediaType,\n        sources: props.media,\n        poster: props.media.poster ?? null,\n        title: querySelector(Selectors.EMBED.elements.title).value,\n        width: querySelector(Selectors.EMBED.elements.width).value,\n        height: querySelector(Selectors.EMBED.elements.height).value,\n        autoplay: querySelector(Selectors.EMBED.elements.mediaAutoplay).checked,\n        loop: querySelector(Selectors.EMBED.elements.mediaLoop).checked,\n        muted: querySelector(Selectors.EMBED.elements.mediaMute).checked,\n        controls: querySelector(Selectors.EMBED.elements.mediaControl).checked,\n        tracks,\n    };\n    mediaDataProps.link = false;\n    return mediaDataProps;\n};\n\n/**\n * Check for video/audio attributes.\n *\n * @param {HTMLElement} elem\n * @param {string} attr Attribute name\n * @returns {boolean}\n */\nexport const hasAudioVideoAttr = (elem, attr) => {\n    // As explained in MDL-64175, some OS (like Ubuntu), are removing the value for these attributes.\n    // So in order to check if attr=\"true\", we need to check if the attribute exists and if the value is empty or true.\n    return (elem.hasAttribute(attr) && (elem.getAttribute(attr) || elem.getAttribute(attr) === ''));\n};\n\n/**\n * Return file mime type from the url.\n *\n * It will check for file extension at end of the url,\n * and if it has no file extension it will return null as no mimetype.\n *\n * @param {string} url\n * @returns {string}\n */\nexport const getFileMimeTypeFromUrl = async(url) => {\n    let fetchedMimeType = null;\n    let fileName = null;\n    const uri = url.split('/');\n    if (uri.length > 0) {\n        fileName = uri[uri.length - 1];\n    }\n\n    const mimeTypes = Selectors.MEDIA_MIME_TYPES;\n    for (const property in mimeTypes) {\n        // Let's check if last uri has dot like \"filename.type\".\n        if (fileName && fileName.includes('.')) {\n            let fileExtension = fileName.split('.');\n            fileExtension = fileExtension[fileExtension.length - 1].toLowerCase();\n            if (fileExtension.includes('?') && (fileExtension.split('?')[0] === property)) {\n                fetchedMimeType = mimeTypes[property];\n            } else if (fileExtension === property) {\n                fetchedMimeType = mimeTypes[property];\n                break;\n            }\n        } else {\n            // Let's mark this as a \"link\".\n            fetchedMimeType = 'link';\n            break;\n        }\n    }\n    return fetchedMimeType;\n};\n"],"names":["props","mediaType","showDropzone","canShowDropZone","showFilePicker","canShowFilePicker","fileType","elementid","editor","id","bodyTemplate","Selectors","EMBED","template","body","insertMediaBody","footerTemplate","footer","insertMediaFooter","selector","type","selectedMedia","mediaElm","selection","getNode","nodeName","toLowerCase","querySelector","async","url","params","media","controls","hasAudioVideoAttr","autoplay","loop","urlParams","isYoutube","youtubeType","isYoutubeUrl","fetchUrl","fetch","youtubeData","JSON","parse","text","youtubeRegex","exec","site","idOrType","playlistCheckRegex","mute","isYoutubePlaylist","test","isShort","includes","isNoCookie","list","title","muted","vimeoVideoIdRegExp","vimeoVideoId","match","vimeoData","replaceAll","youtubeTypes","i","length","context","mediaDetailsBody","mediaDetailsFooter","isVideo","isAudio","isLink","canHaveThumbnail","mediaTagType","isUpdating","isNewFileOrLinkUpload","newMediaLink","newFileUpload","linkMediaType","label","component","value","selected","customsize","linkcustomsize","map","key","moodleLangs","currentLanguage","installed","Object","entries","_ref","lang","code","available","_ref2","subtitleLang","tracks","subtitles","captions","descriptions","chapters","metadata","root","querySelectorAll","elements","mediaMetadataTabPane","forEach","metaData","track","dataset","trackKind","push","src","srclang","trackLang","trackLabel","defaultTrack","trackDefault","checked","element","mediaDataProps","sources","poster","width","height","mediaAutoplay","mediaLoop","mediaMute","mediaControl","link","elem","attr","hasAttribute","getAttribute","fetchedMimeType","fileName","uri","split","mimeTypes","MEDIA_MIME_TYPES","property","fileExtension"],"mappings":"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"}