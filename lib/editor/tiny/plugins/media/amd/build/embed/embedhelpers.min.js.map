{"version":3,"file":"embedhelpers.min.js","sources":["../../src/embed/embedhelpers.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny media plugin embed helpers.\n *\n * This provides easy access to any classes without instantiating a new object.\n *\n * @module      tiny_media/embed/embedhelpers\n * @copyright   2024 Stevani Andolo <stevani@hotmail.com.au>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Selectors from '../selectors';\nimport {getStrings, getString} from 'core/str';\nimport {component} from \"../common\";\nimport {\n    getCurrentLanguage,\n    getMoodleLang\n} from 'editor_tiny/options';\nimport {createUrlParams} from '../helpers';\n\n/**\n * Return template context for insert media.\n *\n * @param {object} props\n * @returns {object}\n */\nexport const insertMediaTemplateContext = (props) => {\n    return {\n        mediaType: props.mediaType,\n        showDropzone: props.canShowDropZone,\n        showFilePicker: props.canShowFilePicker,\n        fileType: 'audi/video',\n    };\n};\n\n/**\n * Return template context for insert media.\n *\n * @param {object} props\n * @returns {object}\n */\nexport const insertMediaThumbnailTemplateContext = (props) => {\n    return {\n        elementid: props.editor.id,\n        showDropzone: props.canShowDropZone,\n        bodyTemplate: Selectors.EMBED.template.body.insertMediaBody,\n        footerTemplate: Selectors.EMBED.template.footer.insertMediaFooter,\n        fileType: 'image',\n        selector: Selectors.EMBED.type,\n    };\n};\n\n/**\n * Return selected media type and element.\n *\n * @param {editor} editor\n * @returns {Array}\n */\nexport const getSelectedMediaElement = (editor) => {\n    let mediaType = null;\n    let selectedMedia = null;\n    const mediaElm = editor.selection.getNode();\n\n    if (!mediaElm) {\n        mediaType = null;\n        selectedMedia = null;\n    } else if (mediaElm.nodeName.toLowerCase() === 'video' || mediaElm.nodeName.toLowerCase() === 'audio') {\n        mediaType = mediaElm.nodeName.toLowerCase();\n        selectedMedia = mediaElm;\n    } else if (mediaElm.querySelector('video')) {\n        mediaType = 'video';\n        selectedMedia = mediaElm.querySelector('video');\n    } else if (mediaElm.querySelector('audio')) {\n        mediaType = 'audio';\n        selectedMedia = mediaElm.querySelector('audio');\n    }\n\n    return [mediaType, selectedMedia];\n};\n\n/**\n * This is used to format the media url (without file extension),\n * so it can be previewed from the following providers:\n * 1. YouTube.\n * 2. Vimeo.\n *\n * If the links are based on the checks the type will be \"link\",\n * otherwise it will be \"null\" and the url will be later checked in ::getFileMimeTypeFromUrl().\n *\n * @param {string} url\n * @param {object} props\n * @returns {Array} Array of formatted url and type.\n */\nexport const formatMediaUrl = (url, props) => {\n    let params = {};\n    let media = null;\n\n    // Check if selectedMedia prop is has value.\n    if (props.selectedMedia) {\n        media = props.selectedMedia;\n\n        // Create object of params.\n        params = {\n            controls: audioVideoBoolAttr(media, 'controls') ? '1' : '0',\n            autoplay: audioVideoBoolAttr(media, 'autoplay') ? '1' : '0',\n            loop: audioVideoBoolAttr(media, 'loop'),\n        };\n    }\n\n    let urlParams = '';\n    if (url.includes('https://www.youtube.com/')) {\n        // Only applies if selectedMedia prop has value.\n        if (props.selectedMedia) {\n            // YouTube mute param is \"mute\".\n            params.mute = audioVideoBoolAttr(media, 'muted');\n            urlParams = '?' + createUrlParams(params);\n        }\n\n        return [\n            // YouTube original link: https://www.youtube.com/watch?v=abc012&params.\n            url.replace('watch?v=', 'embed/') + urlParams,\n            // YouTube embed link: https://www.youtube.com/embed/abc012?params.\n            'link'\n        ];\n    } else if (url.includes('https://vimeo.com/')) {\n        // Only applies if selectedMedia prop has value.\n        if (props.selectedMedia) {\n            // Vimeo mute param is \"muted\".\n            params.muted = audioVideoBoolAttr(media, 'muted');\n            urlParams = '?' + createUrlParams(params);\n        }\n\n        return [\n            // Vimeo original link: https://vimeo.com/012345?params.\n            url.replaceAll('vimeo.com', 'player.vimeo.com/video') + urlParams,\n            // Vimeo embed link: https://player.vimeo.com/video/012345?params.\n            'link'\n        ];\n    }\n\n    // Return original url and \"null\" as the type.\n    return [url, null];\n};\n\n/**\n * Return template context for media details.\n *\n * @param {object} props\n * @returns {object}\n */\nexport const mediaDetailsTemplateContext = async(props) => {\n    const context = {\n        bodyTemplate: Selectors.EMBED.template.body.mediaDetailsBody,\n        footerTemplate: Selectors.EMBED.template.footer.mediaDetailsFooter,\n        isVideo: (props.mediaType === 'video'),\n        isAudio: (props.mediaType === 'audio'),\n        isLink: (props.mediaType === 'link'),\n        canHaveThumbnail: (props.mediaType === 'video' || props.mediaTagType === 'video'),\n        isUpdating: props.isUpdating,\n        isNewFileOrLinkUpload: (props.newMediaLink || props.newFileUpload),\n        selector: Selectors.EMBED.type,\n    };\n\n    // Props for link mediaType to form a select element for audio and video.\n    if (context.isLink) {\n        context.linkMediaType = [\n            {\n                label: await getString('audio', component),\n                value: 'audio',\n                selected: (props.mediaTagType === 'audio') ? 'selected' : '',\n            },\n            {\n                label: await getString('video', component),\n                value: 'video',\n                selected: (props.mediaTagType === 'video') ? 'selected' : '',\n            }\n        ];\n    }\n\n    return {...context, ...props};\n};\n\n/**\n * Get help strings.\n *\n * @returns {object}\n */\nexport const getHelpStrings = async() => {\n    const [\n        customsize,\n    ] = await getStrings([\n        'customsize_help',\n    ].map((key) => ({\n        key,\n        component,\n    })));\n\n    return {\n        customsize,\n    };\n};\n\n/**\n * Get current moodle languages.\n *\n * @param {editor} editor\n * @returns {object}\n */\nexport const prepareMoodleLang = (editor) => {\n    const moodleLangs = getMoodleLang(editor);\n    const currentLanguage = getCurrentLanguage(editor);\n\n    const installed = Object.entries(moodleLangs.installed).map(([lang, code]) => ({\n        lang,\n        code,\n        \"default\": lang === currentLanguage,\n    }));\n\n    const available = Object.entries(moodleLangs.available).map(([lang, code]) => ({\n        lang,\n        code,\n        \"default\": lang === currentLanguage,\n    }));\n\n    return {\n        installed,\n        available,\n    };\n};\n\n/**\n * Return moodle lang.\n *\n * @param {string} subtitleLang\n * @param {editor} editor\n * @returns {object|null}\n */\nexport const getMoodleLangObj = (subtitleLang, editor) => {\n    const {available} = getMoodleLang(editor);\n\n    if (available[subtitleLang]) {\n        return {\n            lang: subtitleLang,\n            code: available[subtitleLang],\n        };\n    }\n\n    return null;\n};\n\n/**\n * Get media data from the inserted media.\n *\n * @param {object} props\n * @returns {object}\n */\nexport const getEmbeddedMediaDetails = (props) => {\n    const tracks = {\n        subtitles: [],\n        captions: [],\n        descriptions: [],\n        chapters: [],\n        metadata: []\n    };\n\n    const mediaMetadata = props.root.querySelectorAll(Selectors.EMBED.elements.mediaMetadataTabPane);\n    mediaMetadata.forEach(metaData => {\n        const trackElements = metaData.querySelectorAll(Selectors.EMBED.elements.track);\n        trackElements.forEach(track => {\n            tracks[metaData.dataset.trackKind].push({\n                src: track.querySelector(Selectors.EMBED.elements.url).value,\n                srclang: track.querySelector(Selectors.EMBED.elements.trackLang).value,\n                label: track.querySelector(Selectors.EMBED.elements.trackLabel).value,\n                defaultTrack: track.querySelector(Selectors.EMBED.elements.trackDefault).checked,\n            });\n        });\n    });\n\n    const querySelector = (element) => props.root.querySelector(element);\n    const mediaDataProps = {};\n    mediaDataProps.media = {\n        type: props.mediaType,\n        sources: props.media,\n        poster: props.media.poster ?? null,\n        title: querySelector(Selectors.EMBED.elements.title).value,\n        width: querySelector(Selectors.EMBED.elements.width).value,\n        height: querySelector(Selectors.EMBED.elements.height).value,\n        autoplay: querySelector(Selectors.EMBED.elements.mediaAutoplay).checked,\n        loop: querySelector(Selectors.EMBED.elements.mediaLoop).checked,\n        muted: querySelector(Selectors.EMBED.elements.mediaMute).checked,\n        controls: querySelector(Selectors.EMBED.elements.mediaControl).checked,\n        tracks,\n    };\n    mediaDataProps.link = false;\n    return mediaDataProps;\n};\n\n/**\n * Check for video/audio attributes.\n *\n * @param {HTMLElement} elem\n * @param {string} attr Attribute name\n * @returns {boolean}\n */\nexport const audioVideoBoolAttr = (elem, attr) => {\n    // As explained in MDL-64175, some OS (like Ubuntu), are removing the value for these attributes.\n    // So in order to check if attr=\"true\", we need to check if the attribute exists and if the value is empty or true.\n    return (elem.hasAttribute(attr) && (elem.getAttribute(attr) || elem.getAttribute(attr) === ''));\n};\n\n/**\n * Return file mime type from the url.\n *\n * It will check for file extension at end of the url,\n * and if it has no file extension it will return null as no mimetype.\n *\n * @param {string} url\n * @returns {string}\n */\nexport const getFileMimeTypeFromUrl = async(url) => {\n    let fetchedMimeType = null;\n    const mimeTypes = Selectors.MEDIA_MIME_TYPES;\n    for (const property in mimeTypes) {\n        const uri = url.split('/');\n        const fileName = uri[uri.length - 1];\n        let fileExtension = fileName.split('.');\n\n        // Let's check if last uri has dot like \"filename.type\".\n        if (fileName.includes('.')) {\n            fileExtension = fileExtension[fileExtension.length - 1].toLowerCase();\n            if ((fileExtension.includes('/') || fileExtension.includes('?')) && fileExtension.includes(property)) {\n                fetchedMimeType = mimeTypes[property];\n            } else if (fileExtension === property) {\n                fetchedMimeType = mimeTypes[property];\n                break;\n            }\n        } else {\n            // Let's mark this as a \"link\".\n            fetchedMimeType = 'link';\n            break;\n        }\n    }\n    return fetchedMimeType;\n};\n"],"names":["props","mediaType","showDropzone","canShowDropZone","showFilePicker","canShowFilePicker","fileType","elementid","editor","id","bodyTemplate","Selectors","EMBED","template","body","insertMediaBody","footerTemplate","footer","insertMediaFooter","selector","type","selectedMedia","mediaElm","selection","getNode","nodeName","toLowerCase","querySelector","url","params","media","controls","audioVideoBoolAttr","autoplay","loop","urlParams","includes","mute","replace","muted","replaceAll","async","context","mediaDetailsBody","mediaDetailsFooter","isVideo","isAudio","isLink","canHaveThumbnail","mediaTagType","isUpdating","isNewFileOrLinkUpload","newMediaLink","newFileUpload","linkMediaType","label","component","value","selected","customsize","map","key","moodleLangs","currentLanguage","installed","Object","entries","_ref","lang","code","available","_ref2","subtitleLang","tracks","subtitles","captions","descriptions","chapters","metadata","root","querySelectorAll","elements","mediaMetadataTabPane","forEach","metaData","track","dataset","trackKind","push","src","srclang","trackLang","trackLabel","defaultTrack","trackDefault","checked","element","mediaDataProps","sources","poster","title","width","height","mediaAutoplay","mediaLoop","mediaMute","mediaControl","link","elem","attr","hasAttribute","getAttribute","fetchedMimeType","mimeTypes","MEDIA_MIME_TYPES","property","uri","split","fileName","length","fileExtension"],"mappings":";;;;;;;;;+fAwC2CA,QAChC,CACHC,UAAWD,MAAMC,UACjBC,aAAcF,MAAMG,gBACpBC,eAAgBJ,MAAMK,kBACtBC,SAAU,4DAUkCN,QACzC,CACHO,UAAWP,MAAMQ,OAAOC,GACxBP,aAAcF,MAAMG,gBACpBO,aAAcC,mBAAUC,MAAMC,SAASC,KAAKC,gBAC5CC,eAAgBL,mBAAUC,MAAMC,SAASI,OAAOC,kBAChDZ,SAAU,QACVa,SAAUR,mBAAUC,MAAMQ,wCAUMZ,aAChCP,UAAY,KACZoB,cAAgB,WACdC,SAAWd,OAAOe,UAAUC,iBAE7BF,SAG0C,UAApCA,SAASG,SAASC,eAAiE,UAApCJ,SAASG,SAASC,eACxEzB,UAAYqB,SAASG,SAASC,cAC9BL,cAAgBC,UACTA,SAASK,cAAc,UAC9B1B,UAAY,QACZoB,cAAgBC,SAASK,cAAc,UAChCL,SAASK,cAAc,WAC9B1B,UAAY,QACZoB,cAAgBC,SAASK,cAAc,WAVvC1B,UAAY,KACZoB,cAAgB,MAYb,CAACpB,UAAWoB,wCAgBO,CAACO,IAAK5B,aAC5B6B,OAAS,GACTC,MAAQ,KAGR9B,MAAMqB,gBACNS,MAAQ9B,MAAMqB,cAGdQ,OAAS,CACLE,SAAUC,mBAAmBF,MAAO,YAAc,IAAM,IACxDG,SAAUD,mBAAmBF,MAAO,YAAc,IAAM,IACxDI,KAAMF,mBAAmBF,MAAO,cAIpCK,UAAY,UACZP,IAAIQ,SAAS,6BAETpC,MAAMqB,gBAENQ,OAAOQ,KAAOL,mBAAmBF,MAAO,SACxCK,UAAY,KAAM,4BAAgBN,SAG/B,CAEHD,IAAIU,QAAQ,WAAY,UAAYH,UAEpC,SAEGP,IAAIQ,SAAS,uBAEhBpC,MAAMqB,gBAENQ,OAAOU,MAAQP,mBAAmBF,MAAO,SACzCK,UAAY,KAAM,4BAAgBN,SAG/B,CAEHD,IAAIY,WAAW,YAAa,0BAA4BL,UAExD,SAKD,CAACP,IAAK,4CAS0Ba,MAAAA,cACjCC,QAAU,CACZhC,aAAcC,mBAAUC,MAAMC,SAASC,KAAK6B,iBAC5C3B,eAAgBL,mBAAUC,MAAMC,SAASI,OAAO2B,mBAChDC,QAA8B,UAApB7C,MAAMC,UAChB6C,QAA8B,UAApB9C,MAAMC,UAChB8C,OAA6B,SAApB/C,MAAMC,UACf+C,iBAAuC,UAApBhD,MAAMC,WAAgD,UAAvBD,MAAMiD,aACxDC,WAAYlD,MAAMkD,WAClBC,sBAAwBnD,MAAMoD,cAAgBpD,MAAMqD,cACpDlC,SAAUR,mBAAUC,MAAMQ,aAI1BsB,QAAQK,SACRL,QAAQY,cAAgB,CACpB,CACIC,YAAa,kBAAU,QAASC,mBAChCC,MAAO,QACPC,SAAkC,UAAvB1D,MAAMiD,aAA4B,WAAa,IAE9D,CACIM,YAAa,kBAAU,QAASC,mBAChCC,MAAO,QACPC,SAAkC,UAAvB1D,MAAMiD,aAA4B,WAAa,MAK/D,IAAIP,WAAY1C,gCAQGyC,gBAEtBkB,kBACM,mBAAW,CACjB,mBACFC,KAAKC,OACHA,IAAAA,IACAL,UAAAA,6BAGG,CACHG,WAAAA,wCAU0BnD,eACxBsD,aAAc,0BAActD,QAC5BuD,iBAAkB,+BAAmBvD,cAcpC,CACHwD,UAbcC,OAAOC,QAAQJ,YAAYE,WAAWJ,KAAIO,WAAEC,KAAMC,iBAAW,CAC3ED,KAAAA,KACAC,KAAAA,aACWD,OAASL,oBAWpBO,UARcL,OAAOC,QAAQJ,YAAYQ,WAAWV,KAAIW,YAAEH,KAAMC,kBAAW,CAC3ED,KAAAA,KACAC,KAAAA,aACWD,OAASL,gDAgBI,CAACS,aAAchE,gBACrC8D,UAACA,YAAa,0BAAc9D,eAE9B8D,UAAUE,cACH,CACHJ,KAAMI,aACNH,KAAMC,UAAUE,eAIjB,uCAS6BxE,sCAC9ByE,OAAS,CACXC,UAAW,GACXC,SAAU,GACVC,aAAc,GACdC,SAAU,GACVC,SAAU,IAGQ9E,MAAM+E,KAAKC,iBAAiBrE,mBAAUC,MAAMqE,SAASC,sBAC7DC,SAAQC,WACIA,SAASJ,iBAAiBrE,mBAAUC,MAAMqE,SAASI,OAC3DF,SAAQE,QAClBZ,OAAOW,SAASE,QAAQC,WAAWC,KAAK,CACpCC,IAAKJ,MAAM1D,cAAchB,mBAAUC,MAAMqE,SAASrD,KAAK6B,MACvDiC,QAASL,MAAM1D,cAAchB,mBAAUC,MAAMqE,SAASU,WAAWlC,MACjEF,MAAO8B,MAAM1D,cAAchB,mBAAUC,MAAMqE,SAASW,YAAYnC,MAChEoC,aAAcR,MAAM1D,cAAchB,mBAAUC,MAAMqE,SAASa,cAAcC,sBAK/EpE,cAAiBqE,SAAYhG,MAAM+E,KAAKpD,cAAcqE,SACtDC,eAAiB,UACvBA,eAAenE,MAAQ,CACnBV,KAAMpB,MAAMC,UACZiG,QAASlG,MAAM8B,MACfqE,mCAAQnG,MAAM8B,MAAMqE,0DAAU,KAC9BC,MAAOzE,cAAchB,mBAAUC,MAAMqE,SAASmB,OAAO3C,MACrD4C,MAAO1E,cAAchB,mBAAUC,MAAMqE,SAASoB,OAAO5C,MACrD6C,OAAQ3E,cAAchB,mBAAUC,MAAMqE,SAASqB,QAAQ7C,MACvDxB,SAAUN,cAAchB,mBAAUC,MAAMqE,SAASsB,eAAeR,QAChE7D,KAAMP,cAAchB,mBAAUC,MAAMqE,SAASuB,WAAWT,QACxDxD,MAAOZ,cAAchB,mBAAUC,MAAMqE,SAASwB,WAAWV,QACzDhE,SAAUJ,cAAchB,mBAAUC,MAAMqE,SAASyB,cAAcX,QAC/DtB,OAAAA,QAEJwB,eAAeU,MAAO,EACfV,sBAUEjE,mBAAqB,CAAC4E,KAAMC,OAG7BD,KAAKE,aAAaD,QAAUD,KAAKG,aAAaF,OAAqC,KAA5BD,KAAKG,aAAaF,sFAY/CpE,MAAAA,UAC9BuE,gBAAkB,WAChBC,UAAYtG,mBAAUuG,qBACvB,MAAMC,YAAYF,UAAW,OACxBG,IAAMxF,IAAIyF,MAAM,KAChBC,SAAWF,IAAIA,IAAIG,OAAS,OAC9BC,cAAgBF,SAASD,MAAM,SAG/BC,SAASlF,SAAS,KAQf,CAEH4E,gBAAkB,gBATlBQ,cAAgBA,cAAcA,cAAcD,OAAS,GAAG7F,eACnD8F,cAAcpF,SAAS,MAAQoF,cAAcpF,SAAS,OAASoF,cAAcpF,SAAS+E,UACvFH,gBAAkBC,UAAUE,eACzB,GAAIK,gBAAkBL,SAAU,CACnCH,gBAAkBC,UAAUE,wBASjCH"}