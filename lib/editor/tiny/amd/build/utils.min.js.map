{"version":3,"file":"utils.min.js","sources":["../src/utils.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {renderForPromise} from 'core/templates';\nimport {getFilePicker} from './options';\n\n/**\n * Get the image path for the specified image.\n *\n * @param {string} identifier The name of the image\n * @param {string} component The component name\n * @return {string} The image URL path\n */\nexport const getImagePath = (identifier, component = 'editor_tiny') => Promise.resolve(M.util.image_url(identifier, component));\n\nexport const getButtonImage = async(identifier, component = 'editor_tiny') => renderForPromise('editor_tiny/toolbar_button', {\n    image: await getImagePath(identifier, component),\n});\n\n/**\n * Helper to display a filepicker and return a Promise.\n *\n * The Promise will resolve when a file is selected, or reject if the file type is not found.\n *\n * @param {TinyMCE} editor\n * @param {string} filetype\n * @returns {Promise<object>} The file object returned by the filepicker\n */\nexport const displayFilepicker = (editor, filetype) => new Promise((resolve, reject) => {\n    const configuration = getFilePicker(editor, filetype);\n    if (configuration) {\n        const options = {\n            ...configuration,\n            formcallback: resolve,\n        };\n        M.core_filepicker.show(Y, options);\n        return;\n    }\n    reject(`Unknown filetype ${filetype}`);\n});\n\n/**\n * Given a TinyMCE Toolbar configuration, add the specified button to the named section.\n *\n * @param {object} toolbar\n * @param {string} section\n * @param {string} button\n * @returns {object} The toolbar configuration\n */\nexport const addToolbarButton = (toolbar, section, button) => {\n    if (!toolbar) {\n        return [{\n            name: section,\n            items: [button],\n        }];\n    }\n\n    const mutatedToolbar = JSON.parse(JSON.stringify(toolbar));\n    return mutatedToolbar.map((item) => {\n        if (item.name === section) {\n            item.items.push(button);\n        }\n\n        return item;\n    });\n};\n\n/**\n * Given a TinyMCE Menubar configuration, add the specified button to the named section.\n *\n * @param {object} menubar\n * @param {string} section\n * @param {string} menuitem\n * @returns {object}\n */\nexport const addMenubarItem = (menubar, section, menuitem) => {\n    if (!menubar) {\n        const emptyMenubar = {};\n        emptyMenubar[section] = {\n            title: section,\n            items: menuitem,\n        };\n    }\n\n    const mutatedMenubar = JSON.parse(JSON.stringify(menubar));\n    Array.from(Object.entries(mutatedMenubar)).forEach(([name, menu]) => {\n        if (name === section) {\n            menu.items = `${menu.items} ${menuitem}`;\n        }\n    });\n\n    return mutatedMenubar;\n};\n\n/**\n * Given a TinyMCE contextmenu configuration, add the specified button to the end.\n *\n * @param {string} contextmenu\n * @param {string} menuitem\n * @returns {string}\n */\nexport const addContextmenuItem = (contextmenu, menuitem) => {\n    const contextmenuItems = (contextmenu ?? '').split(' ');\n\n    return contextmenuItems\n        .concat(menuitem)\n        .filter((item) => item !== '')\n        .join(' ');\n};\n\n/**\n * Get the link to the user documentation for the named plugin.\n *\n * @param {string} pluginName\n * @returns {string}\n */\nexport const getDocumentationLink = (pluginName) => `https://docs.moodle.com/en/editor_tiny/${pluginName}`;\n"],"names":["getImagePath","identifier","component","Promise","resolve","M","util","image_url","getButtonImage","renderForPromise","image","editor","filetype","reject","configuration","options","formcallback","core_filepicker","show","Y","toolbar","section","button","JSON","parse","stringify","map","item","name","items","push","menubar","menuitem","mutatedMenubar","Array","from","Object","entries","forEach","menu","contextmenu","split","concat","filter","join","pluginName"],"mappings":"4lFAyBaA,aAAe,SAACC,gBAAYC,iEAAY,qBAAkBC,QAAQC,QAAQC,EAAEC,KAAKC,UAAUN,WAAYC,4DAEvGM,4CAAiB,iBAAMP,sJAAYC,qDAAY,0BAAkBO,4CAC7DT,aAAaC,WAAYC,gEAAtCQ,4DAD2F,ygBAa9D,SAACC,OAAQC,iBAAa,IAAIT,SAAQ,SAACC,QAASS,YACnEC,eAAgB,0BAAcH,OAAQC,aACxCE,mBACMC,uCACCD,mBACHE,aAAcZ,UAElBC,EAAEY,gBAAgBC,KAAKC,EAAGJ,cAG9BF,kCAA2BD,yCAWC,SAACQ,QAASC,QAASC,eAC1CF,QAOkBG,KAAKC,MAAMD,KAAKE,UAAUL,UAC3BM,KAAI,SAACC,aACnBA,KAAKC,OAASP,SACdM,KAAKE,MAAMC,KAAKR,QAGbK,QAZA,CAAC,CACJC,KAAMP,QACNQ,MAAO,CAACP,mCAsBU,SAACS,QAASV,QAASW,cACxCD,aAQCE,eAAiBV,KAAKC,MAAMD,KAAKE,UAAUM,iBACjDG,MAAMC,KAAKC,OAAOC,QAAQJ,iBAAiBK,SAAQ,kDAAEV,cAAMW,cACnDX,OAASP,UACTkB,KAAKV,gBAAWU,KAAKV,kBAASG,cAI/BC,4CAUuB,SAACO,YAAaR,iBAClBQ,MAAAA,YAAAA,YAAe,IAAIC,MAAM,KAG9CC,OAAOV,UACPW,QAAO,SAAChB,YAAkB,KAATA,QACjBiB,KAAK,oCASsB,SAACC,mEAAyDA"}